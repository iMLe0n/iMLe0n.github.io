<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/08/12/hello-world/"/>
    <url>/2020/08/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MacOS Catalina 不能在根目录下创建文件夹</title>
    <link href="/2020/05/29/2020-05-29-MacOs-Catalina%E4%B8%8D%E8%83%BD%E5%9C%A8%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/"/>
    <url>/2020/05/29/2020-05-29-MacOs-Catalina%E4%B8%8D%E8%83%BD%E5%9C%A8%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="MacOS升级到Catalina-10-15-4根目录不能创建目录"><a href="#MacOS升级到Catalina-10-15-4根目录不能创建目录" class="headerlink" title="MacOS升级到Catalina 10.15.4根目录不能创建目录"></a>MacOS升级到Catalina 10.15.4根目录不能创建目录</h2><h4 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h4><p>启动公司某模块项目,发现启动不来,查看控制台日志发现不能初始化日志文件指定目录,于是乎手动在本机使用命令行创建目录</p><pre><code class="hljs shell">mkdir -p /data/xxx/xxx</code></pre><p>发现报错, 只读文件系统,根本创建不来目录,切换为root,亦是如此</p><pre><code class="hljs shell">Read-only file system</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>MacOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>龙女士的日常矫情---2018-09-16</title>
    <link href="/2020/05/29/2019-11-14-%E9%BE%99%E5%A5%B3%E5%A3%AB%E6%96%87%E7%AB%A0/"/>
    <url>/2020/05/29/2019-11-14-%E9%BE%99%E5%A5%B3%E5%A3%AB%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<iframe frameborder="no" marginwidth="0" marginheight="0" src="//music.163.com/outchain/player?type=2&id=236405&auto=1&height=66"></iframe><p>路人甲<br>下班的轟隆車潮中，他跌坐在大馬路上。<br>額頭流血，满褲子濕透，一片黑，暮色裡看不出是血還是尿。两只皮鞋脱落。他垂著的頭，似乎還在滴血，狀態可怖。<br>醉了跌倒了？被車撞了？最糟的是，在這亂衝疾走的車陣中，他隨時可能被輾過。<br>汽車從他身旁閃過，路人從他身旁走過，没有人停下来。<br>「你要我叫救護車嗎？」我大聲問。他不語，只是摇頭。<br>大陸救護車打什麼號碼我其實並不知道。<br>「要我打電話给你家人嗎？」<br>他好像沒力氣回答，只是搖頭。<br>「你要喝水嗎？」他又虛弱地搖頭。<br>一輛麵包車開到他前面，準備倒車進停車格，我敲駕駛的車窗：「不要倒車了，你要撞到他了。」<br>駕駛生氣開罵：「哪裡不好坐，坐這裡擋我停車。」<br>我說，「我拉不動他。您下車來把他扶到路邊，他安全了，您也可以停車了。」<br>駕駛奇怪地看我一眼，一踩油門，走了。<br>一個女人拉著菜籃車經過，看看地上受傷的人，看看我，我說，「你們這裡的緊急電話是什麼？」<br>她說，「不知道。別管他，喝醉了吧⋯⋯」<br>我開始內心掙扎：不懂「國情」，是不是就不管了呢⋯⋯<br>可是，顯然沒有人會停下腳步幫助他，他一定會被車撞….<br>於是我轉向一邊的店家，騎樓裡一個紮著馬尾的女孩一直站在那兒看熱鬧，我問她：「你們附近有派出所嗎？」<br>女孩說，「前面二百米。」<br>快步往前，剛到派出所大門前，一輛警車正要開走，我趕上去敲車窗，做手勢要裡面的人滑下窗。<br>電光石火之間，腦裡閃過無數聽過的、看過的與公安有關的印象和念頭：這是一個什麼樣的體制、體制中公安的角色、警察和人民之間的關係、人們對武警的各種說法、全球流傳的「城管」的各種不可思議的乖張行為視頻……<br>車窗下來了，一個中年的警官和我四眼相對。我直截了當：「前面二百米，大藥房對面，有一個受傷的人坐在馬路中間，非常危險，麻煩你們去幫助他。」<br>他看看我，說，「好。」<br>心裡深藏的不信任使我急切：「我知道你們可能有別的事情，但是這個人在馬路中間非常危險，你們一定要立刻過去。」<br>警官或許也不習慣見到這麼固執的路人甲，停頓了一下，說，「好的。」<br>我還是不放心——他們會不會把那人當罪犯對待啊？<br>我說，「請問你們會怎麼處理？」<br>警官說，「我們會叫120急救。」<br>車子準備往前移動，我發現我對這個警官鍥而不捨，跟了兩步，大聲說，「您承諾我一定會去？而且『現在』就去，對吧？」<br>他點頭。車開走。<br>我往前繼續原來的探索路程。這是瀋陽，《大江大海》書寫過的戰場。我背著一個小背包，到了書裡寫到過的「瀋陽車站」，下火車找了一個旅館，就逛到了西塔街。<br>邊走邊猶豫：我該回頭嗎？<br>我發現我有點不敢回頭。<br>不敢回頭，是怯懦，是怕，怕那人還坐在危險又荒涼的馬路中間，怕警察根本沒去管他，怕一個又一個路人仍舊揚長而去，而我再度站在那裡又什麼都做不了，只得到一份對人性的失望、對這個地方更強烈的不信任….所以，不要回頭吧。<br>前面繁華已盡，路燈昏暗了，我——哎，還是回頭吧。<br>加緊腳步回到原點，就目擊了這一幕：<br>警察已經把傷者扶到了人行道坐在階梯上。原來跟我對話的警官看見我，跟我解釋：「喝醉了，朋友把他丟下就走了。他摔傷了。已經打電話給他家人，家人都不在…..」<br>「我可以拍照嗎？」<br>「可以啊。」<br>一個警察正在問：「我們送你回家好不好？你的地址說得出來嗎⋯⋯」<br>幾個警察幾乎是「溫柔」地扶著這個被酒友拋棄而受傷的小市民，上了警車。<br>望著警車逐漸沒入車水馬龍的夜色中，我心想：今晚可上了一課，關於中國、關於我自己的某些成見⋯⋯<br>基層警察的舉止是文明的一個指標，很重要的一個指標。</p><p><img src="/img/long_1.jpg" alt="龙女士1"></p><p><img src="/img/long_2.jpg" alt="龙女士2"></p>]]></content>
    
    
    
    <tags>
      
      <tag>龙应台</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之模板方法模式（Template Method）</title>
    <link href="/2020/05/29/2019-05-13-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88Template-Method%EF%BC%89/"/>
    <url>/2020/05/29/2019-05-13-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88Template-Method%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式之模板方法模式（Template-Method）"><a href="#设计模式之模板方法模式（Template-Method）" class="headerlink" title="设计模式之模板方法模式（Template Method）"></a>设计模式之模板方法模式（Template Method）</h2><p>​                    <strong>身体很重要</strong></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a><strong>要点</strong></h3><ul><li>“模板方法”定义了算法的步骤，把这些步骤的实现延迟到子类。</li><li>模板方法模式为我们提供了一种代码复用的重要技巧。</li><li>模板方法的抽象类可以定义具体方法、抽象方法和钩子。</li><li>抽象方法由子类实现。</li><li>钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要去覆盖它。</li><li>为了防止子类改变模板方法中的算法，可以将模板方法声明为 final。</li><li>好莱坞原则告诉我们，将决策权放到高层模块中，以便决定如何以及何时调用底层模块。</li><li>你将在真实世界代码中看到模板方法模式的许多变体，不要期待它们全都是一眼就可以被你认出的。</li><li>策略模式和模板方法模式都封装算法，一个用组合，一个用继承。</li><li>工厂方法是模板方法的一个特殊版本。</li></ul><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a><strong>设计原则</strong></h3><p>好莱坞原则</p><p>​    别调用（打电话给）我们，我们会调用（打电话给你）。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a><strong>类图</strong></h3><p><img src="/img/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h3><p><img src="/img/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0.png"></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CaffeineBeverage</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareRecipe</span><span class="hljs-params">()</span> </span>&#123;        boilWater();        brew();        pourInCup();        addCondiments();    &#125;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">brew</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCondiments</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">boilWater</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Boiling water&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pourInCup</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Pouring into cup&quot;</span>);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coffee</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CaffeineBeverage</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">brew</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Dripping Coffee through filter&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addCondiments</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Adding Sugar and Milk&quot;</span>);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tea</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CaffeineBeverage</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">brew</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Steeping the tea&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addCondiments</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Adding Lemon&quot;</span>);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeverageTestDrive</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Tea tea = <span class="hljs-keyword">new</span> Tea();        Coffee coffee = <span class="hljs-keyword">new</span> Coffee();        System.out.println(<span class="hljs-string">&quot;\nMaking tea...&quot;</span>);        tea.prepareRecipe();        System.out.println(<span class="hljs-string">&quot;\nMaking coffee...&quot;</span>);        coffee.prepareRecipe();        TeaWithHook teaHook = <span class="hljs-keyword">new</span> TeaWithHook();        CoffeeWithHook coffeeHook = <span class="hljs-keyword">new</span> CoffeeWithHook();        System.out.println(<span class="hljs-string">&quot;\nMaking tea...&quot;</span>);        teaHook.prepareRecipe();        System.out.println(<span class="hljs-string">&quot;\nMaking coffee...&quot;</span>);        coffeeHook.prepareRecipe();    &#125;&#125;</code></pre><p>完整代码已经上传至<a href="https://github.com/iMLe0n/DesignPatterns/tree/master/src/templatemethod">github</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大蕉ElasticSearch分享</title>
    <link href="/2020/05/29/2019-06-20-%E5%A4%A7%E8%95%89ElasticSearch%E5%88%86%E4%BA%AB/"/>
    <url>/2020/05/29/2019-06-20-%E5%A4%A7%E8%95%89ElasticSearch%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="大蕉ElasticSearch分享"><a href="#大蕉ElasticSearch分享" class="headerlink" title="大蕉ElasticSearch分享"></a>大蕉ElasticSearch分享</h1><h2 id="ElasticSearch究竟是什么"><a href="#ElasticSearch究竟是什么" class="headerlink" title="ElasticSearch究竟是什么"></a>ElasticSearch究竟是什么</h2><p>今日主题：ElasticSearch 杂谈</p><p>我想跟大家先讲这么一个故事。</p><p>在2017年，我有幸参与到ElasticSearch 的创始人 Shay Banon 的现场分享。</p><p>Shay Banon在谈及当年接触 Lucene 并开发 Elasticsearch 的初衷的时候， Shay Banon 认为自己参与 Lucene 完全是一种偶然。</p><p>ElasticSearch 开发出来的初衷，竟然是为了一个菜谱。</p><p>当年Shay Banon还是一个待业工程师，跟随自己的新婚妻子来到伦敦，妻子想在伦敦学习做一名厨师，而自己则想为妻子开发一个方便搜索菜谱的应用，所以才接触到 Lucene。(注释:Lucene是一个开源的全文检索引擎工具包)</p><p>那为什么又会有ElasticSearch呢？因为直接使用 Lucene 构建搜索有很多问题，包含大量重复性的工作，所以 Shay Banon 便在 Lucene 的基础上不断地进行抽象，让 Java 程序嵌入搜索变得更容易，经过一段时间的打磨便诞生了他的第一个开源作品“Compass”，中文即“指南针”的意思。</p><p>大概大神都是这样吧，就是解决自己生活中遇到的一个小问题，然后一不小心，喔，完成了一部史诗级的世界性软件巨作</p><p>之后，他找到了一份面对高性能分布式开发环境的新工作，在工作中他渐渐发现越来越需要一个易用的、高性能、实时、分布式搜索服务，于是决定重写 Compass，将它从一个库打造成了一个独立的 server，并创建了开源项目，也就是后来的 Elasticsearch。</p><p>ElasticSearch ，是基于Lucene构建的开源、分布式、高性能、高可用、可伸缩、Restful接口的全文搜索和分析系统。</p><p>故事讲完了，大家一定很好奇，搜索引擎不是一个非常难的东西吗？你看百度，Google，不都是一个搜索引擎，这太复杂了趴？</p><p>对啊！搜索引擎就是一个非常难的东西啊，所以我们今天的主角 ElasticSearch 才简单得可贵。</p><p>现在公布今天分享的主要内容，比较忙的同学看完就可以去忙其他事情了。</p><p>ElasticSearch 是一门准实时的搜索引擎，而不仅仅是一门用于搜索的实时搜索引擎，ELK（ElasticSearch、Logstash、Kibana）是当前比较稳的模式。<br>大蕉曾经在线上处理存量十几亿，增量几百万的反欺诈。<br>ElasticSearch 已经在 阿里云，腾讯云有云服务。</p><p>现在稍微介绍下自己。hello大家好，我是今天的分享人大蕉。大蕉毕业后就职于平安，完成了平安普惠大数据几十亿数据的风控反欺诈系统的从0到1，先就职于阿里，正在对大批量线下设备的运维监控告警提供方案和平台支持。</p><p>我们这样来定位 ElasticSearch<br>1、分布式的搜索引擎和数据分析引擎<br>2、全文检索、结构化检索、数据分析<br>3、对海量数据进行近实时处理</p><p>这里面我们可以抓住几个关键词，分布式、全文、数据分析、海量、近实时。其他中文都好理解，近实时是什么鬼？</p><p>这个我们会放在最后解密</p><p>我们先聊几个比较常见的业务场景。</p><p>1、在服务器日志文件中查找某个错误日志信息<br>2、在大量新闻中查找出现某位明星的新闻<br>3、在代码库中搜索某行代码段信息<br>4、在电商网站上输入某个商品，高亮显示商品的关键字。</p><p>如果没有搜索引擎，我们会怎么做？</p><p>like or like or like  or like  or like  or like</p><p>别无他法，数据库疯狂的   like or like or like .你扛得住？我反正扛不住。</p><p>那凭什么你大蕉说完成这些述求可以使用 ElasticSearch 呢？我就不信。</p><p>首先，ElasticSearch 在业界已经得到广泛的应用和验证。</p><p>比如极客时间的副产品极客搜索。检索系统就是采用开源的 Elasticsearch，从近实时、可扩展、中文分词、搜准率和同义词等几个角度出发，对聚合结果按规则进行索引构建，并进行了部分同义词调优。</p><p><img src="/img/%E6%9E%81%E5%AE%A2%E6%90%9C%E7%B4%A2.jpg" alt="极客搜索"></p><p>新浪使用ES 如何分析处理32亿条实时日志，阿里使用 ES 构建挖财自己的日志采集和分析体系，有赞使用ES进行业务日志处理。</p><p>早在2013年初，GitHub就抛弃了Solr，采取ElasticSearch 来做PB级的搜索。而维基百科，早早就启动了以elasticsearch为基础的核心搜索架构。 SoundCloud使用ElasticSearch为1.8亿用户提供即时而精准的音乐搜索服务”。</p><p>说了这么多，你大蕉做了啥？</p><p><img src="/img/%E5%A4%A7%E8%95%89es.jpg" alt="平安风控反欺诈系统"></p><p>大蕉毕业后就职于平安，完成了平安普惠大数据几十亿数据的风控反欺诈系统的从0到1的搭建，其中 ElasticSearch 就是作为核心的存储和搜索系统，完成百万用户社交网络的秒级反欺诈风控。</p><p>好，说了这么多，我想用，那我怎么知道怎么用呢？难道把原来的 MySQL全部迁移到所谓的 ElasticSearch 上？这不太可能吧。</p><p>没关系的，这里有两条非常非常好走的路供你走。</p><p>1、追加到现有系统中<br>如果你已经有一个在运行的复杂的系统，你的需求之一是在现有系统中添加检索服务。一种非常冒险的方式是重构系统以支持ES。而相对安全的方式是：将ES作为新的组件添加到现有系统中。比如 mysql、oracle选择 logstash-input-jdbc 插件同步即可。然后直接在原有系统里直接调用 ElasticSearch 的搜索服务就好了。<br>2、直接用 ELK 技术栈，一行代码都不用，直接用 Beats + Logstash 收集数据，ElasticSearch 作为存储引擎， Kibana 作为图表和搜索产品直接使用。</p><p>还有一个疑问，为什么说 ElasticSearch 不仅仅是用于搜索？</p><p>其实 ElasticSearch 还提供了一套非常好的数据分析API，以及一套非常好的机器学习的API。所以作为实时的 OLAP 平台也是胜任的。</p><p>那我怎么入门 ElasticSearch 呢？</p><p> <a href="https://www.elastic.co/guide/index.html">https://www.elastic.co/guide/index.html</a> 这个网站上有官方权威的中文版教程，从安装，搜索，原理，应用，都有很完善的教程和案例，可以在里边按顺序翱翔。</p><p>如果要自己玩，那么下边的四步其实就搞定了：<br>下载 <a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a><br>解压<br>bin/elastic<br>浏览器输入  <a href="http://127.0.0.1:9200/">http://127.0.0.1:9200/</a></p><p>当然还有很多人关注客户端的问题，就是支持哪些语言。</p><p><a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a> HTTP/Java/Go/JavaScript/.NET/PHP/Perl/Python/Ruby/Hadoop/Spark  等</p><p>简单来说，你能想到的语言，基本都支持。。</p><p>为什么选它？</p><p>1、简单，没有额外条件，自成集群。<br>2、开源，Java 实现，稳。<br>3、水平扩展是真的优秀。<br>4、全文索引暂时没见到比这个好的。<br>5、中文分词也已经做得很棒了。<br>6、各种客户端非常齐全。</p><p>有什么坑？<br>1、权限、告警、安全、报告、图表、机器学习，不是开源的，需要交钱。<br>2、事务控制并不好。</p><p>好,不知道大家是不是忘了刚刚我说的，准实时的问题了。</p><p>为什么说 ElasticSearch 是准实时的?</p><p>为了提高索引性能，Elasticsearch 在写入数据时候，采用延迟写入的策略，即数据先写到内存中，当超过默认 1 秒会进行一次写入操作，就是将内存中 segment 数据刷新到操作系统中，此时我们才能将数据搜索出来，所以这就是为什么 Elasticsearch 提供的是近实时搜索功能，而不是实时搜索功能。当然像我们的内部系统对数据延迟要求不高的话，我们可以通过延长 refresh 时间间隔，可以有效的减少 segment 合并压力，提供索引速度。</p><p>如果说你只能记住一点点东西，那么就记住下面两句话吧。</p><p>ElasticSearch 是一门准实时的搜索引擎，而不仅仅是一门用于搜索的实时搜索引擎，OLAP也支持，客户端也很丰富。<br>搜索引擎并没有想象中那么难使用，别怕，自己搭建很方便，各种云服务也很齐全。</p><p>好了，分享环节完结撒花。</p><h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a><strong>提问</strong></h3><p>1.事务控制并不好。一般怎么避免处理?</p><p>需要事务控制的场景，自行切换到其他支持事务的数据库上</p><p>2.大蕉了解solr不，为啥用es不用solr 我司就还在用solr进行搜索</p><p>Solr 索引效率没有 ES 高，非常明显，主要在io这快，ES在实时搜索领域碾压solr。</p><p>3.多表关联查询支持吗?</p><p>ES6.X 后支持，我使用的场景不多，更多还是单索引内的聚合。</p><p>4.es适不适用全量存储，可以当做“db”用，还是要存储索引用字段，和主键，再查bd或者缓存之类的?</p><p>可以直接当db用,ES 自带备份，负载均衡。如果是搜索的场景，或者匹配的场景，比传统的DB支持性更好，数据安全也有不错的保障。</p><p>5.之前没接触过ES，想问下，对于远程主机文件内容搜索是否可以支持，比如说我有很多云主机，文件都在云主机的log目录下，我想要搜索这些日志文件里的关键字内容，做一个日志查询的功能？</p><p>使用 Logstach，全部同步到 ElasticSearch 就好了，很方便。<br>在每个云主机上，安装一个类似 Agent 的采集器东西，就可以了。比如官方就有一款叫 BEATS <a href="https://www.elastic.co/cn/products/beats">https://www.elastic.co/cn/products/beats</a></p><p><img src="/img/beats1.jpg"></p><p><img src="/img/beats2.jpg"></p><p>6.利用ES如何设计一套自动化运维系统，做到线上问题实时告警等功能，能否简单讲讲这方面架构层次的东西</p><p>我现在无法回答你，问题我留着，思考完回答你。这是一个比较复杂的问题</p><p>7.日志在不断增加，那每次将日志加载进es是整个文件全量重新导入还是有增量的设计</p><p>一般日志都是追加，都是增量设计。如果一定要全量，一定要自己设置好主键</p><p>8.我理解es是不是适用于对实时性要求不高的场景</p><p>恰恰相反，es就是适用于实时性比较高的场景。所谓的准实时，是指1秒后能搜索到，基本等于实时。</p><p>9.直接进es吗 还是mq到es ？去重怎么样？</p><p>只能根据id去重，如果对于重复要求很高，要自行设计id系统，先查询后写入。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ElasticSearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/05/29/2019-05-21-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%88Composite%EF%BC%89/"/>
    <url>/2020/05/29/2019-05-21-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%88Composite%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>layout: post<br>title: 设计模式之组合模式（Composite）<br>description: “设计模式之组合模式（Composite）”<br>modified: 2019-05-21<br>tags: [设计模式]<br>image:<br>  path: /img/abstract-7.jpg<br>  feature: abstract-7.jpg<br>  credit: iMLe0n</p><h2 id="设计模式之组合模式（Composite）"><a href="#设计模式之组合模式（Composite）" class="headerlink" title="设计模式之组合模式（Composite）"></a>设计模式之组合模式（Composite）</h2><p><strong>只要你坚持做某件事情，那你就在那个领域比百分之九十的人成功了</strong></p><h3 id="组合模式的概念"><a href="#组合模式的概念" class="headerlink" title="组合模式的概念"></a>组合模式的概念</h3><p>组合模式，也叫 Composite 模式……是构造型的设计模式之一。</p><p>组合模式允许对象组合成树形结构，来表现“整体/部分”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。</p><p>Composite Pattern</p><p>Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.</p><p>有一些拗口，通俗的说：组合模式是关于怎样将对象形成树形结构来表现整体和部分的层次结构的成熟模式。</p><p>使用组合模式，可以让用户以一致的方式处理个体对象和组合对象，组合模式的关键在于无论是个体对象还是组合对象都实现了相同的接口或都是同一个抽象类的子类。</p><p>即，组合模式，它能通过递归来构造树形的对象结构，并可以通过一个对象来访问整个对象树。</p><p>即，组合模式，在大多数情况下，可以让客户端忽略对象个体和对象组合之间的差异。</p><h3 id="组合模式的角色和类图"><a href="#组合模式的角色和类图" class="headerlink" title="组合模式的角色和类图"></a>组合模式的角色和类图</h3><p>结合数据结构里的树，其实很好写出来。无非就是叶子和非叶子节点的的组合。</p><p>1、需要一个类为叶子节点和非叶子节点的共同抽象父类，如图里的 Component 接口（抽象类也可以），是树形结构的节点的抽象：</p><ul><li>为所有的对象，包括叶子节点，定义统一的接口（公共属性，行为等的定义）</li><li>提供管理子节点对象的接口方法</li><li>[可选]提供管理父节点对象的接口方法</li></ul><p>2、设计一个 Leaf 类代表树的叶节点，这个要单独拿出来区分，是 Component 的实现子类</p><p>3、设计一个 Composite 类作为树枝节点，即非叶节点，也是 Component 的实现子类</p><p>4、client 客户端，它使用 Component 接口操作树</p><h3 id="组合（Composite）、组件（Component接口）、和树的关系"><a href="#组合（Composite）、组件（Component接口）、和树的关系" class="headerlink" title="组合（Composite）、组件（Component接口）、和树的关系"></a>组合（Composite）、组件（Component接口）、和树的关系</h3><p>在该模式里熟悉一些定义，其实没必要死记硬背，定义随便起名字，只要能自洽即可。</p><p>1、组合（Composite）包含了组件（Component）</p><p>2、组件 Component 接口 = 组合Composite + 叶节点Leaf，因为组件是抽象的，叶子和枝节点（组合）是组件的具体表现，很好理解。</p><p>其实就是递归，得到的是由上而下的树形结构，根部是一个组合Composite，而组合的分支延伸展开（组合包含了组件），直至叶子节点leaf为止。</p><h3 id="基于组合模式改进迭代器模式里的菜单系统"><a href="#基于组合模式改进迭代器模式里的菜单系统" class="headerlink" title="基于组合模式改进迭代器模式里的菜单系统"></a>基于组合模式改进迭代器模式里的菜单系统</h3><p>如菜单子系统的实现，就是典型的树状结构</p><p>需要一个抽象组件 Component，例子里是 MenuComponent，作为菜单节点和菜单节点项（叶子）的共同接口，能够让客户端使用统一的方法来操作菜单和菜单项。</p><p>如下，所有的组件（叶子+树枝（非叶子））都必须实现这个组件接口，又因为叶子节点（即菜单项）和树枝节点（即组合节点）分工不同，所以需要在抽象的组件类中实现默认的方法，因为某些方法可能只在某类节点中有意义。一般是做抛出运行时异常（自定义的异常）的处理。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-21 下午9:35</span><span class="hljs-comment"> * 菜单和菜单项的抽象——组件，让菜单和菜单项能共用</span><span class="hljs-comment"> * 又因为希望这个抽象组件能提供一些默认的操作，故使用了抽象类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuComponent</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MenuComponent menuComponent)</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(MenuComponent menuComponent)</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> MenuComponent <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isVegetarian</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;&#125;</code></pre><p>下面编写叶子节点——菜单的菜单项类。</p><p>这是组合模式类图里的叶子角色，它只负责实现组合的内部元素的行为，因此宏观上管理整个菜单的方法，比如 add 、remove 等，它不应该复写，对她没有意义。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-21 下午9:37</span><span class="hljs-comment"> * 叶子节点，代表菜单里的一项</span><span class="hljs-comment"> * 只复写对其有意义的方法，没有意义的方法，比如获得子节点等，就不理会即可</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuItem</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MenuComponent</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String description;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> vegetarian;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> price;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MenuItem</span><span class="hljs-params">(String name, String description, <span class="hljs-keyword">boolean</span> vegetarian, <span class="hljs-keyword">double</span> price)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.description = description;        <span class="hljs-keyword">this</span>.vegetarian = vegetarian;        <span class="hljs-keyword">this</span>.price = price;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> description;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> price;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isVegetarian</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> vegetarian;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;        System.out.print(<span class="hljs-string">&quot;  &quot;</span> + getName());        <span class="hljs-keyword">if</span> (isVegetarian()) &#123;            System.out.print(<span class="hljs-string">&quot;(v)&quot;</span>);        &#125;        System.out.println(<span class="hljs-string">&quot;, &quot;</span> + getPrice());        System.out.println(<span class="hljs-string">&quot;     -- &quot;</span> + getDescription());    &#125;&#125;</code></pre><p>下面，编写树枝节点——菜单，也就是组合类。</p><p>之前的菜单项是的单个的组件类，而组合类才体现了递归思想，组合类聚合了组件类。一些对其没有意义的方法，同样不需要复写实现。</p><p>菜单也可以有子菜单（菜单项其实本质也可以是子菜单），所以组合了一个 Arraylist<MenuComponent>，因为菜单和菜单项都属于 MenuComponent，那么使用同样的方法，可以兼顾两者，这正应了组合模式的意义—— 使用组合模式，可以让用户以一致的方式处理个体对象和组合对象，组合模式的关键在于无论是个体对象还是组合对象都实现了相同的接口或都是同一个抽象类的子类。 </p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-21 下午9:39</span><span class="hljs-comment"> * 树枝节点，也就是组合节点——代表各个菜单</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Menu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MenuComponent</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String description;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 依赖了菜单组件，递归的实现</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> List&lt;MenuComponent&gt; menuComponents = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Menu</span><span class="hljs-params">(String name, String description)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.description = description;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MenuComponent menuComponent)</span> </span>&#123;        menuComponents.add(menuComponent);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(MenuComponent menuComponent)</span> </span>&#123;        menuComponents.remove(menuComponent);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> MenuComponent <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">return</span> menuComponents.get(i);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> description;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 因为菜单作为树枝节点，它是一个组合，包含了菜单项和其他的子菜单，所以 print()应该打印出它包含的一切。</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;        System.out.print(<span class="hljs-string">&quot;\n&quot;</span> + getName());        System.out.println(<span class="hljs-string">&quot;, &quot;</span> + getDescription());        System.out.println(<span class="hljs-string">&quot;---------------------&quot;</span>);        <span class="hljs-comment">// 使用了迭代器（迭代器模式和组合模式的有机结合），遍历菜单的菜单项</span>        Iterator iterator = menuComponents.iterator();        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            <span class="hljs-comment">// 打印这个节点包含的一切，print 可以兼顾两类节点，这是组合模式的特点</span>            MenuComponent menuComponent = (MenuComponent) iterator.next();            menuComponent.print(); <span class="hljs-comment">// 递归思想的应用</span>        &#125;    &#125;&#125;</code></pre><p>因为菜单是一个组合，包含了菜单项和其他的子菜单，所以它的print()应该打印出它包含的一切，此时递归思想派上了用场。</p><p>下面编写客户端——服务员类</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-21 下午9:47</span><span class="hljs-comment"> * 客户端，也就是服务员类，聚合了菜单组件接口（这里是抽象类）控制菜单，解耦合</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Waitress</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 聚合了菜单组件——这一抽象节点，能兼顾叶子节点和树枝节点</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> MenuComponent allMenus;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Waitress</span><span class="hljs-params">(MenuComponent allMenus)</span> </span>&#123;        <span class="hljs-keyword">this</span>.allMenus = allMenus;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMenu</span><span class="hljs-params">()</span> </span>&#123;        allMenus.print();    &#125;&#125;</code></pre><p>客户端类代码很简单，只需要聚合一个顶层的组件接口即可。最顶层的菜单组件可以兼顾所有菜单或者菜单项，故客户端只需要调用一次最顶层的print方法，即可打印整个菜单系统。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-21 下午9:50</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuTestDrive</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 创建所有的菜单系统，它们本质上都是组合节点——MenuComponent</span>        MenuComponent pancakeHouseMenu = <span class="hljs-keyword">new</span> Menu(<span class="hljs-string">&quot;PANCAKE HOUSE MENU&quot;</span>, <span class="hljs-string">&quot;Breakfast&quot;</span>);        MenuComponent dinerMenu = <span class="hljs-keyword">new</span> Menu(<span class="hljs-string">&quot;DINER MENU&quot;</span>, <span class="hljs-string">&quot;Lunch&quot;</span>);        MenuComponent cafeMenu = <span class="hljs-keyword">new</span> Menu(<span class="hljs-string">&quot;CAFE MENU&quot;</span>, <span class="hljs-string">&quot;Dinner&quot;</span>);        MenuComponent dessertMenu = <span class="hljs-keyword">new</span> Menu(<span class="hljs-string">&quot;DESSERT MENU&quot;</span>, <span class="hljs-string">&quot;Dessert of course!&quot;</span>);        <span class="hljs-comment">// 创建顶级root节点——allMenus，代表整个菜单系统</span>        MenuComponent allMenus = <span class="hljs-keyword">new</span> Menu(<span class="hljs-string">&quot;ALL MENUS&quot;</span>, <span class="hljs-string">&quot;All menus combined&quot;</span>);        allMenus.add(pancakeHouseMenu); <span class="hljs-comment">// 把每个菜单系统，组合到root节点，当做树枝节点</span>        allMenus.add(dinerMenu);        allMenus.add(cafeMenu);        <span class="hljs-comment">// 为煎饼屋的菜单系统，增加菜单项</span>        pancakeHouseMenu.add(<span class="hljs-keyword">new</span> MenuItem(                <span class="hljs-string">&quot;K&amp;B&#x27;s Pancake Breakfast&quot;</span>,                <span class="hljs-string">&quot;Pancakes with scrambled eggs, and toast&quot;</span>,<span class="hljs-keyword">false</span>,<span class="hljs-number">12.5</span>));<span class="hljs-comment">// 为餐厅的菜单系统，增加菜单项</span>        dinerMenu.add(<span class="hljs-keyword">new</span> MenuItem(<span class="hljs-string">&quot;Vegetarian BLT&quot;</span>, <span class="hljs-string">&quot;(Fakin&#x27;) Bacon with lettuce &amp; tomato on whole wheat&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">15.2</span>));        dinerMenu.add(<span class="hljs-keyword">new</span> MenuItem(<span class="hljs-string">&quot;BLT&quot;</span>, <span class="hljs-string">&quot;Bacon with lettuce &amp; tomato on whole wheat&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">14.5</span>));        <span class="hljs-comment">// 为餐厅的菜单系统，增加子菜单——这个其实也是菜单项，但是，是树枝，这是一个饭后甜点子菜单</span>        dinerMenu.add(dessertMenu);        <span class="hljs-comment">// 为饭后甜点菜单系统，增加菜单项</span>        dessertMenu.add(<span class="hljs-keyword">new</span> MenuItem(<span class="hljs-string">&quot;Apple Pie&quot;</span>, <span class="hljs-string">&quot;Apple pie with a flakey crust, topped with vanilla icecream&quot;</span>,<span class="hljs-keyword">false</span>,<span class="hljs-number">12.7</span>));        dessertMenu.add(<span class="hljs-keyword">new</span> MenuItem(<span class="hljs-string">&quot;Cheesecake&quot;</span>, <span class="hljs-string">&quot;Creamy New York cheesecake, with a chocolate graham crust&quot;</span>,<span class="hljs-keyword">false</span>,<span class="hljs-number">14.5</span>));        <span class="hljs-comment">// 为咖啡厅菜单系统，增加菜单项</span>        cafeMenu.add(<span class="hljs-keyword">new</span> MenuItem(                <span class="hljs-string">&quot;Veggie Burger and Air Fries&quot;</span>,                <span class="hljs-string">&quot;Veggie burger on a whole wheat bun, lettuce, tomato, and fries&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-number">17.2</span>));        <span class="hljs-comment">// 把整个菜单传给客户端</span>        Waitress waitress = <span class="hljs-keyword">new</span> Waitress(allMenus);        waitress.printMenu();    &#125;&#125;</code></pre><h3 id="单一职责和组合模式的矛盾"><a href="#单一职责和组合模式的矛盾" class="headerlink" title="单一职责和组合模式的矛盾"></a>单一职责和组合模式的矛盾</h3><p>这是一个很典型的折中设计问题：有时候会故意违反一些设计原则，去实现一些特殊需求。还是那句话，学习设计模式不要死记硬背，最后还是要遵循具体的技术条件和 <strong>服务于特定的</strong> 业务场景。</p><p>回顾案例发现：组合模式不但要管理整个菜单——这个树状层次结构，还要执行菜单的一些具体操作动作。明显的，违反了单一职责原则，可以这么说：组合模式牺牲了单一职责的设计原则，换取了程序的透明性（transparency）——通过让组件的接口同时包含一些树枝子节点（组合节点）和叶子子节点的操作，客户就可以将组合节点和叶子节点一视同仁，而一个元素究竟是组合节点还是叶子节点对客户都是透明的。</p><p>如果不让组件接口同时具备多种类型节点的操作，虽然设计上安全，职责也分开，但是失去了透明性，即客户端必须显示的使用条件（一般用 instanceOf ）来判断节点类型</p><h3 id="迭代器模式-组合模式来实现分担部分责任"><a href="#迭代器模式-组合模式来实现分担部分责任" class="headerlink" title="迭代器模式 + 组合模式来实现分担部分责任"></a>迭代器模式 + 组合模式来实现分担部分责任</h3><p>可让客户端使用迭代器模式去遍历整个菜单系统，比方说，女招待可能想要游走整个菜单，只打印 / 挑选素食的菜单项。</p><p>想要实现一个组合模式+迭代器模型的菜单系统，可以为每个组件都加上 createIterator() 方法。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-21 下午10:04</span><span class="hljs-comment"> * 先从抽象的组件节点入手，加上迭代器</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuComponent</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MenuComponent menuComponent)</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(MenuComponent menuComponent)</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> MenuComponent <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isVegetarian</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;    <span class="hljs-comment">// 加上迭代器，这里直接使用 JDK 的迭代器</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;&#125;</code></pre><p>同样的套路，编写叶子节点和树枝节点，继承这个抽象类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Menu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MenuComponent</span> </span>&#123;    <span class="hljs-keyword">private</span> List&lt;MenuComponent&gt; menuComponents = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String description;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Menu</span><span class="hljs-params">(String name, String description)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.description = description;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MenuComponent menuComponent)</span> </span>&#123;        menuComponents.add(menuComponent);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(MenuComponent menuComponent)</span> </span>&#123;        menuComponents.remove(menuComponent);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> MenuComponent <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;        <span class="hljs-keyword">return</span> menuComponents.get(i);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> description;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CompositeIterator(menuComponents.iterator());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;        Iterator iterator = menuComponents.iterator();        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            MenuComponent menuComponent = (MenuComponent) iterator.next();            menuComponent.print();        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuItem</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MenuComponent</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String description;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> vegetarian;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> price;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MenuItem</span><span class="hljs-params">(String name, String description, <span class="hljs-keyword">boolean</span> vegetarian, <span class="hljs-keyword">double</span> price)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.description = description;        <span class="hljs-keyword">this</span>.vegetarian = vegetarian;        <span class="hljs-keyword">this</span>.price = price;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> description;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> price;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isVegetarian</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> vegetarian;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NullIterator();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;        System.out.print(<span class="hljs-string">&quot;  &quot;</span> + getName());        <span class="hljs-keyword">if</span> (isVegetarian()) &#123;            System.out.print(<span class="hljs-string">&quot;(vegetable)&quot;</span>);        &#125;        System.out.println(<span class="hljs-string">&quot;, &quot;</span> + getPrice());        System.out.println(<span class="hljs-string">&quot;     -- &quot;</span> + getDescription());    &#125;&#125;</code></pre><p>发现了两个新东西，一个是 NullIterator() 和 CompositeIterator()，尤其是后者，使用了递归思想。</p><p>回忆：在写 MenuComponent 类的 print 方法时，利用了一个迭代器遍历组件内的每个项，如果遇到的是菜单，就会递归地调度 print 方法处理它，换句话说，MenuComponent 是在“内部”自行处理遍历——内部迭代器模式。</p><p>但是在如下的 CompositeIterator 中，实现的是一个“外部”的迭代器，所以有许多需要追踪的事情。外部迭代器必须维护它在遍历中的位置，以便外部可以通过 hasNext 和 next 来驱动遍历。在 CompositeIterator 中，必须维护组合递归结构的位置，这也是为什么在组合层次结构中上上下下时，使用堆栈 JDK 的 Stack 来维护游标的位置。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-21 下午10:07</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompositeIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;    <span class="hljs-keyword">private</span> Stack&lt;Iterator&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    <span class="hljs-comment">// 把要遍历的 Menu 组合的迭代器 iterator 传入，menuComponents.iterator() 被传入一个 stack 中保存位置</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CompositeIterator</span><span class="hljs-params">(Iterator iterator)</span> </span>&#123;        stack.push(iterator);    &#125;    <span class="hljs-comment">// 当客户端需要取得下一个元素的时候，先判断是否存在下一个元素</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (hasNext()) &#123;            Iterator iterator = stack.peek(); <span class="hljs-comment">// 仅查看当前的栈顶元素——迭代器，不出栈</span>            MenuComponent component = (MenuComponent) iterator.next(); <span class="hljs-comment">// 使用该栈顶的迭代器，取出要遍历的组合的元素</span>            <span class="hljs-keyword">if</span> (component <span class="hljs-keyword">instanceof</span> Menu) &#123;                <span class="hljs-comment">// 如果取出的元素仍然是菜单，那需要继续遍历它，故要记录它的位置，把它的迭代器取出来</span>                <span class="hljs-comment">// 调用 component.createIterator() 返回 CompositeIterator，这个 CompositeIterator 仍然包含一个自己的 stack，继续存入栈中</span>                stack.push(component.createIterator());            &#125;            <span class="hljs-keyword">return</span> component;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (stack.empty()) &#123; <span class="hljs-comment">// 如果栈是空，直接返回 false</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            Iterator iterator = stack.peek(); <span class="hljs-comment">// 仅查看当前的栈顶元素——迭代器，不出栈</span>            <span class="hljs-comment">// 判断当前的顶层元素是否还有下一个元素，如果栈空了，就说明当前顶层元素没有下一个元素，返回 false，此处判断为 true</span>            <span class="hljs-keyword">if</span> (!iterator.hasNext()) &#123;                stack.pop(); <span class="hljs-comment">// 如果当前栈顶元素，没有下一个元素了，就把当前栈顶元素出栈，递归的继续判断下一个元素</span>                <span class="hljs-keyword">return</span> hasNext();            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否则表示还有下一个元素，直接返回 true</span>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;&#125;</code></pre><p>参考 <a href="http://www.cnblogs.com/jose1125/p/5294972.html">java.util.Stack类中的peek()方法</a></p><p>通过测试，来观察上述代码的执行过程：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCompositeStack</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MenuComponent pancakeHouseMenu = <span class="hljs-keyword">new</span> Menu(<span class="hljs-string">&quot;PANCAKE HOUSE MENU&quot;</span>, <span class="hljs-string">&quot;Breakfast&quot;</span>);        <span class="hljs-comment">// 创建顶级root节点——allMenus，代表整个菜单系统</span>        MenuComponent allMenus = <span class="hljs-keyword">new</span> Menu(<span class="hljs-string">&quot;ALL MENUS&quot;</span>, <span class="hljs-string">&quot;All menus combined&quot;</span>);        allMenus.add(pancakeHouseMenu); <span class="hljs-comment">// 把菜单系统，组合到root节点，当做树枝节点</span>        <span class="hljs-comment">// 为煎饼小屋的菜单系统，增加菜单项</span>        pancakeHouseMenu.add(<span class="hljs-keyword">new</span> MenuItem(                <span class="hljs-string">&quot;K&amp;B&#x27;s Pancake Breakfast&quot;</span>,                <span class="hljs-string">&quot;Pancakes with scrambled eggs, and toast&quot;</span>,<span class="hljs-keyword">false</span>,<span class="hljs-number">12.4</span>));        pancakeHouseMenu.add(<span class="hljs-keyword">new</span> MenuItem(                <span class="hljs-string">&quot;Regular Pancake Breakfast&quot;</span>,                <span class="hljs-string">&quot;Pancakes with fried eggs, sausage&quot;</span>,<span class="hljs-keyword">false</span>,<span class="hljs-number">15</span>));        testStack(allMenus);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStack</span><span class="hljs-params">(MenuComponent menuComponent)</span> </span>&#123;        CompositeIterator compositeIterator = <span class="hljs-keyword">new</span> CompositeIterator(menuComponent.createIterator());        <span class="hljs-keyword">while</span> (compositeIterator.hasNext()) &#123;            MenuComponent menuComponent1 = (MenuComponent) compositeIterator.next();        &#125;    &#125;&#125;</code></pre><h3 id="空迭代器"><a href="#空迭代器" class="headerlink" title="空迭代器"></a>空迭代器</h3><p>如果菜单项没什么可以遍历的，比如叶子节点，那么一般要给其遍历方法：</p><p>1、返回 null。可以让 createIterator() 方法返回 null，但是如果这么做，客户端的代码就需要条件语句来判断返回值是否为 null，不太好；</p><p>2、返回一个迭代器，而这个迭代器的 hasNext() 永远返回 false。这个是更好的方案，客户端不用再担心返回值是否为 null。等于创建了一个迭代器，其作用是“没作用”。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NullIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Waitress</span> </span>&#123;    <span class="hljs-keyword">private</span> MenuComponent allMenus;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Waitress</span><span class="hljs-params">(MenuComponent allMenus)</span> </span>&#123;        <span class="hljs-keyword">this</span>.allMenus = allMenus;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMenu</span><span class="hljs-params">()</span> </span>&#123;        allMenus.print();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printVegetarianMenu</span><span class="hljs-params">()</span> </span>&#123;        Iterator iterator = allMenus.createIterator();        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            MenuComponent menuComponent = (MenuComponent) iterator.next();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (menuComponent.isVegetarian()) &#123;                    menuComponent.print();                &#125;            &#125; <span class="hljs-keyword">catch</span> (UnsupportedOperationException ignored) &#123;            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="组合模式和缓存"><a href="#组合模式和缓存" class="headerlink" title="组合模式和缓存"></a>组合模式和缓存</h3><p>有时候，如果组合的结构非常复杂，或者遍历的代价很大，那么可以为组合节点实现一个缓存，如果业务需求是需要不断的遍历一个组合结构，那么可以把遍历的节点存入缓存，省去每次都递归遍历的开支。</p><h3 id="组合模式的优点"><a href="#组合模式的优点" class="headerlink" title="组合模式的优点"></a>组合模式的优点</h3><p>组合模式包含有个体对象和组合对象，并形成树形结构，使用户可以方便地处理个体对象和组合对象。</p><p>1、组合对象和个体对象实现了相同的接口，用户一般不需区分个体对象和组合对象。</p><p>2、当增加新的Composite节点和Leaf节点时，用户的重要代码不需要作出修改。</p><h3 id="其他案例——文件系统也是典型的树状结构系统"><a href="#其他案例——文件系统也是典型的树状结构系统" class="headerlink" title="其他案例——文件系统也是典型的树状结构系统"></a>其他案例——文件系统也是典型的树状结构系统</h3><p>下面使用接口来基于组合模式，实现简单的文件系统</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-21 下午10:24</span><span class="hljs-comment"> * 文件节点抽象(是文件和目录的父类)</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IFile</span> </span>&#123;    <span class="hljs-comment">//显示文件或者文件夹的名称</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(IFile file)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(IFile file)</span></span>;    <span class="hljs-comment">//获得子节点</span>    <span class="hljs-function">List&lt;IFile&gt; <span class="hljs-title">getChild</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">File</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IFile</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">File</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(name);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(IFile file)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(IFile file)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;IFile&gt; <span class="hljs-title">getChild</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Folder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IFile</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">// 聚合了文件抽象节点</span>    <span class="hljs-keyword">private</span> List&lt;IFile&gt; children;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Folder</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        children = <span class="hljs-keyword">new</span> ArrayList&lt;IFile&gt;();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(name);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;IFile&gt; <span class="hljs-title">getChild</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> children;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(IFile file)</span> </span>&#123;        <span class="hljs-keyword">return</span> children.add(file);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(IFile file)</span> </span>&#123;        <span class="hljs-keyword">return</span> children.remove(file);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainClass</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        IFile rootFolder = <span class="hljs-keyword">new</span> Folder(<span class="hljs-string">&quot;/root&quot;</span>);        IFile home = <span class="hljs-keyword">new</span> Folder(<span class="hljs-string">&quot;home&quot;</span>);        IFile user = <span class="hljs-keyword">new</span> Folder(<span class="hljs-string">&quot;imle0n&quot;</span>);        IFile file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;imle0n.java&quot;</span>);        rootFolder.add(home);        rootFolder.add(user);        rootFolder.add(file);        IFile aFolder = <span class="hljs-keyword">new</span> Folder(<span class="hljs-string">&quot;aFolder&quot;</span>);        IFile aFile = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;aFile.txt&quot;</span>);        user.add(aFolder);        user.add(aFile);        displayTree(rootFolder, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">// 层序遍历树</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">displayTree</span><span class="hljs-params">(IFile rootFolder, <span class="hljs-keyword">int</span> deep)</span> </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; deep; i++) &#123;            System.out.print(<span class="hljs-string">&quot;--&quot;</span>);        &#125;        <span class="hljs-comment">//显示自身的名称</span>        rootFolder.display();        <span class="hljs-comment">//获得子树</span>        List&lt;IFile&gt; children = rootFolder.getChild();        <span class="hljs-comment">//遍历子树</span>        <span class="hljs-keyword">for</span>(IFile file : children) &#123;            <span class="hljs-keyword">if</span>(file <span class="hljs-keyword">instanceof</span> File) &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= deep; i++) &#123;                    System.out.print(<span class="hljs-string">&quot;--&quot;</span>);                &#125;                file.display();            &#125; <span class="hljs-keyword">else</span> &#123;                displayTree(file, deep + <span class="hljs-number">1</span>);            &#125;        &#125;    &#125;&#125;</code></pre><p>代码已上传至<a href="https://github.com/iMLe0n/DesignPatterns/tree/master/src/composite">github</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之迭代器模式（Iterator）</title>
    <link href="/2020/05/29/2019-05-20-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Iterator%EF%BC%89/"/>
    <url>/2020/05/29/2019-05-20-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Iterator%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式之迭代器模式（Iterator）"><a href="#设计模式之迭代器模式（Iterator）" class="headerlink" title="设计模式之迭代器模式（Iterator）"></a>设计模式之迭代器模式（Iterator）</h2><p><strong>时光如流水，一去不复返</strong></p><h3 id="聚集（集合）的概念"><a href="#聚集（集合）的概念" class="headerlink" title="聚集（集合）的概念"></a>聚集（集合）的概念</h3><p>如果能把多个普通类的对象聚在一起形成一个总体，这个总体就被称之为聚集(Aggregate)，举例子：</p><p>1、在任何编程语言中：数组都是最基本的聚集，在Java中，数组也是其他的 JAVA 聚集对象的设计基础。</p><p>2、在Java里，JAVA聚集对象都是实现了 java.util.Collection 接口的对象，是 JAVA 对聚集概念的直接支持。从 JDK 1.2 开始，JAVA 提供了多种现成的聚集 API，包括 Vector、ArrayList、HashSet、HashMap、Hashtable、ConcurrentHashMap 等。</p><h3 id="自定义容器的封闭需求"><a href="#自定义容器的封闭需求" class="headerlink" title="自定义容器的封闭需求"></a>自定义容器的封闭需求</h3><p>假如因业务需要，RD 定义了专属的数据元素的聚集，还要把它提供给客户端，让其调用（不特别强调，也包括其他依赖服务）。但是有时候为了安全，RD 不想让客户端看到聚集的内部实现，只是能让她们访问就可以了，比如遍历等操作。还有的时候，客户端不需要了解具体实现，能否让客户端跳开复杂的数据结构？因为调用者们不需要了解实现方式，只要能开箱即用即可。</p><p>为了解决这个问题，那么就需要有一种策略能让客户端遍历这个聚集体的时候，无法窥破RD存储对象的方式，无需了解内部的复杂数据结构。</p><h3 id="迭代器的引出——茶餐厅和煎饼铺子合并的经典案例"><a href="#迭代器的引出——茶餐厅和煎饼铺子合并的经典案例" class="headerlink" title="迭代器的引出——茶餐厅和煎饼铺子合并的经典案例"></a>迭代器的引出——茶餐厅和煎饼铺子合并的经典案例</h3><p>有两个遗留的点餐系统，包括一套餐厅点餐系统——专门提供正餐，和一个煎饼铺子点餐系统（不要纠结为啥煎饼摊也有点餐系统。。。）——专门提供早餐（除了早餐，其他时间不开放）。</p><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>餐厅里有很多卖饭的窗口，它们的业务是一块单独的实现，隔壁煎饼铺的业务，也是一块单独的实现。现在有个老板想把它们收购并合并，让客户能在一个地方，一个时间段内，同时吃煎饼和餐厅的各种菜。目前餐厅内有至少两家餐馆都统一实现了 MenuItem 类——菜单子系统的菜单类。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>但是煎饼的菜单系统用的 ArrayList 记录菜单，而餐厅的 RD 用的是数组实现了菜单系统，双方的RD，都不愿意花费时间修改自己的实现。毕竟有很多其他服务依赖了菜单子系统，如下 MenuItem 代码：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-20 下午8:41</span><span class="hljs-comment"> * 餐厅的菜单都是午餐项目，煎饼的菜单，都是早餐项目，但</span><span class="hljs-comment"> * 它们都属于菜单，即: 都有菜品名称，描述</span><span class="hljs-comment"> * 故设计这样一个类作为菜单项目类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuItem</span> </span>&#123;    String name;    String description;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MenuItem</span><span class="hljs-params">(String name,</span></span><span class="hljs-function"><span class="hljs-params">                    String description)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.description = description;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> description;    &#125;&#125;</code></pre><p>不同的餐厅使用了这个 MenuItem 类</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-20 下午8:53</span><span class="hljs-comment"> * 煎饼窗口的菜单</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PancakeHouseMenu</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * menuItems 使用 ArrayList 存储菜单的项目，动态数组，使其很容易扩大菜单规模</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> List&lt;MenuItem&gt; menuItems;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 在构造菜单的时候，把菜单加入到 ArrayList menuItems</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PancakeHouseMenu</span><span class="hljs-params">()</span> </span>&#123;        menuItems = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        addItem(<span class="hljs-string">&quot;K&amp;B&#x27;s Pancake Breakfast&quot;</span>,                <span class="hljs-string">&quot;Pancakes with scrambled eggs, and toast&quot;</span>);        addItem(<span class="hljs-string">&quot;Regular Pancake Breakfast&quot;</span>,                <span class="hljs-string">&quot;Pancakes with fried eggs, sausage&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(String name, String description)</span> </span>&#123;        MenuItem menuItem = <span class="hljs-keyword">new</span> MenuItem(name, description);        menuItems.add(menuItem);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;MenuItem&gt; <span class="hljs-title">getMenuItems</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> menuItems;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-20 下午8:57</span><span class="hljs-comment"> * 餐厅的菜单</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DinerMenu</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ITEMS = <span class="hljs-number">6</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numberOfItems = <span class="hljs-number">0</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 使用了真正的数组实现菜单项的存储</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> MenuItem[] menuItems;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DinerMenu</span><span class="hljs-params">()</span> </span>&#123;        menuItems = <span class="hljs-keyword">new</span> MenuItem[MAX_ITEMS];        addItem(<span class="hljs-string">&quot;Vegetarian BLT&quot;</span>, <span class="hljs-string">&quot;(Fakin&#x27;) Bacon with lettuce &amp; tomato on whole wheat&quot;</span>);        addItem(<span class="hljs-string">&quot;BLT&quot;</span>, <span class="hljs-string">&quot;Bacon with lettuce &amp; tomato on whole wheat&quot;</span>);        addItem(<span class="hljs-string">&quot;Soup of the day&quot;</span>, <span class="hljs-string">&quot;Soup of the day, with a side of potato salad&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(String name, String description)</span> </span>&#123;        MenuItem menuItem = <span class="hljs-keyword">new</span> MenuItem(name, description);        <span class="hljs-keyword">if</span> (numberOfItems &gt;= MAX_ITEMS) &#123;            System.err.println(<span class="hljs-string">&quot;Sorry, menu is full!  Can&#x27;t add item to menu&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            menuItems[numberOfItems] = menuItem;            numberOfItems = numberOfItems + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">public</span> MenuItem[] getMenuItems() &#123;        <span class="hljs-keyword">return</span> menuItems;    &#125;&#125;</code></pre><p>两种不同的菜单表现方式，会给客户端调用带来很多问题，假设客户端是服务员类——Waitress，下面是客户端的业务：</p><ul><li>打印出菜单上的每一项：打印每份菜单上的所有项，必须调用 PancakeHouseMenu 和 DinerMenu 的 getMenuItem 方法，来取得它们各自的菜单项，但是两者返回类型是不一样的</li><li>只打印早餐项（PancakeHouseMenu 的菜单）或者只打印午餐项（DinerMenu 的菜单）<ul><li>想要打印 PancakeHouseMenu 的项，我们用循环将早餐 ArrayList 内的项列出来</li><li>想要打印 DinerMenu 的项目，我们用循环将数组内的项一一列出来</li></ul></li></ul><p>实现 Waitress 的其他方法，做法都和上面的方法类似，发现 Waitress 处理两个菜单时，总是需要写两个形式相似的循环，去遍历这些菜单，而且一旦外部菜单的数据结构变了，客户端也得跟着修改。</p><p>再有，如果还有第三家餐厅合并，而且坑爹的是，它以完全不同的实现方式实现了菜单……那怎么办？此时难道还继续写第三个循环么……</p><p>以后，这样甚至能发展到 N 个不同形式的循环……</p><p>这显然是非常不好的设计，直接导致后期系统的大量垃圾代码和日益艰巨的维护任务。</p><h3 id="为什么出现这种结局？"><a href="#为什么出现这种结局？" class="headerlink" title="为什么出现这种结局？"></a>为什么出现这种结局？</h3><table><thead><tr><th align="left">封装特性</th><th align="left">面向接口编程</th><th align="left">代码冗余</th></tr></thead><tbody><tr><td align="left">Waitress （也就是客户端）竟然能非常清晰的，而且是必须清晰的熟悉服务端的实现，这是很不科学的</td><td align="left">PancakeHouseMenu 和 DinerMenu 都没有面向接口编程，而直接实现了具体业务，导致扩展困难</td><td align="left">DinerMenu和PancakeHouseMenu都有很大重复代码，没有抽象共享</td></tr></tbody></table><p>那么可以解决么？</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>1、Waitress 要遍历早餐项，需要使用 ArrayList 的 size() 和 get() 方法</p><p>2、Waitress 遍历午餐项，需要使用数组的 length 字段和中括号</p><p>现在创建一个新的对象，将它称为迭代器（Iterator），利用它来封装“遍历集合内的每个对象的过程”，下面对其抽象、封装。</p><h3 id="原则：只封装变化的部分"><a href="#原则：只封装变化的部分" class="headerlink" title="原则：只封装变化的部分"></a>原则：只封装变化的部分</h3><p>案例中变化的部分：因为不同的集合实现，导致的不同的遍历方式。将其封装即可，其实，这正是迭代器模式的应用。迭代器 Iterator，是面向接口编程，故它依赖于一个称为迭代器的接口：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-20 下午9:04</span><span class="hljs-comment"> * 迭代器的接口，一旦有了这个接口，就可以为给种对象集合实现迭代器：数组、列表、散列表等等</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 聚集中，是否还有元素</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 返回聚集中的下一个元素</span><span class="hljs-comment">     */</span>    <span class="hljs-function">Object <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>让餐厅实现迭代器接口 —— Iterator，打造一个餐厅菜单迭代器——DinerMenuIterator</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-20 下午9:05</span><span class="hljs-comment"> * 餐厅的迭代器</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DinerMenuIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;    <span class="hljs-keyword">private</span> MenuItem[] items;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DinerMenuIterator</span><span class="hljs-params">(MenuItem[] items)</span> </span>&#123;        <span class="hljs-keyword">this</span>.items = items;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> position &lt; items.length &amp;&amp; items[position] != <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        MenuItem menuItem = items[position];        position = position + <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> menuItem;    &#125;&#125;</code></pre><p>改造具体餐厅的菜单旧实现，把之前的如下代码删掉，因为它会暴露餐厅菜单的内部数据结构 menuItems</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> MenuItem[] getMenuItems() &#123;    <span class="hljs-keyword">return</span> menuItems;&#125;</code></pre><p>下面是改造之后的餐厅菜单实现，PancakeHouseMenu 实现类似。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-20 下午8:57</span><span class="hljs-comment"> * 餐厅的菜单</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DinerMenu</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ITEMS = <span class="hljs-number">6</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numberOfItems = <span class="hljs-number">0</span>;    <span class="hljs-comment">//使用了真正的数组实现菜单项的存储</span>    <span class="hljs-keyword">private</span> MenuItem[] menuItems;    <span class="hljs-comment">//实现方式不变</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DinerMenu</span><span class="hljs-params">()</span> </span>&#123;        menuItems = <span class="hljs-keyword">new</span> MenuItem[MAX_ITEMS];        addItem(<span class="hljs-string">&quot;Vegetarian BLT&quot;</span>, <span class="hljs-string">&quot;(Fakin&#x27;) Bacon with lettuce &amp; tomato on whole wheat&quot;</span>);        addItem(<span class="hljs-string">&quot;BLT&quot;</span>, <span class="hljs-string">&quot;Bacon with lettuce &amp; tomato on whole wheat&quot;</span>);        addItem(<span class="hljs-string">&quot;Soup of the day&quot;</span>, <span class="hljs-string">&quot;Soup of the day, with a side of potato salad&quot;</span>);    &#125;    <span class="hljs-comment">//实现方式不变</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(String name, String description)</span> </span>&#123;        MenuItem menuItem = <span class="hljs-keyword">new</span> MenuItem(name, description);        <span class="hljs-keyword">if</span> (numberOfItems &gt;= MAX_ITEMS) &#123;            System.err.println(<span class="hljs-string">&quot;Sorry, menu is full!  Can&#x27;t add item to menu&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            menuItems[numberOfItems] = menuItem;            numberOfItems = numberOfItems + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-comment">// 不需要 getMenuItems 方法，因为它会暴露内部实现，返回的直接是菜单的数据结构</span>    <span class="hljs-comment">// 这个新方法代替 getMenuItems，createIterator 返回的是迭代器接口</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DinerMenuIterator(menuItems);    &#125;&#125;</code></pre><p>这样写客户端的代码就不会重复两遍，如下，把迭代器的代码整合到 Waitress，改掉之前冗余的循环遍历代码，只需要传入一个迭代器作为遍历方法的参数，把遍历聚集的工作，委托给迭代器实现。既能保护内部实现，也能抽象遍历形式，精简代码。也符合了开闭原则——以后菜单的实现逻辑修改了，客户端也不用修改调用的代码。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Waitress</span> </span>&#123;    <span class="hljs-comment">// 服务员依赖的菜单系统</span>    <span class="hljs-keyword">private</span> PancakeHouseMenu pancakeHouseMenu;    <span class="hljs-keyword">private</span> DinerMenu dinerMenu;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Waitress</span><span class="hljs-params">(PancakeHouseMenu pancakeHouseMenu, DinerMenu dinerMenu)</span> </span>&#123;        <span class="hljs-keyword">this</span>.pancakeHouseMenu = pancakeHouseMenu;        <span class="hljs-keyword">this</span>.dinerMenu = dinerMenu;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMenu</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// 把迭代器子类型，传入</span>        Iterator pancakeIterator = pancakeHouseMenu.createIterator();        Iterator dinerIterator = dinerMenu.createIterator();        printMenu(pancakeIterator);        printMenu(dinerIterator);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 接口的用法，向上转型</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMenu</span><span class="hljs-params">(Iterator iterator)</span></span>&#123;        <span class="hljs-comment">// 先判断是否还能继续迭代</span>        <span class="hljs-keyword">while</span>(iterator.hasNext())&#123;            <span class="hljs-comment">// Iterator 接口里 next 返回的是 Object 对象，故需要强制转换</span>            MenuItem menuItem = (MenuItem) iterator.next();            System.out.print(menuItem.getName() + <span class="hljs-string">&quot;, &quot;</span>);            System.out.println(menuItem.getDescription());        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuTestDrive</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        PancakeHouseMenu pancakeHouseMenu = <span class="hljs-keyword">new</span> PancakeHouseMenu();        DinerMenu dinerMenu = <span class="hljs-keyword">new</span> DinerMenu();        Waitress waitress = <span class="hljs-keyword">new</span> Waitress(pancakeHouseMenu,dinerMenu);        waitress.printMenu();    &#125;&#125;</code></pre><h3 id="到底解决了什么问题"><a href="#到底解决了什么问题" class="headerlink" title="到底解决了什么问题"></a>到底解决了什么问题</h3><p>经迭代器模式对菜单系统进行封装，使得各个餐厅的菜单系统能维持不变，磨平了实现的差别，减少了重写的工作量。</p><table><thead><tr><th align="left">旧版代码的客户端</th><th align="left">基于迭代器模式封装服务后，重写的客户端</th></tr></thead><tbody><tr><td align="left">遍历：需要多个代码重复度较高的循环来实现，代码冗余度很高，加大无意义的工作量</td><td align="left">只需要增加类，去实现各个菜单系统的迭代器，客户端只需要一个循环就能搞定所有的菜单服务调用</td></tr><tr><td align="left">各个菜单系统的具体实现，封装的不行，对客户端暴露了数据结构，这是没有任何必要的</td><td align="left">菜单的具体实现被封装，对外只公开迭代器，客户端不知道，也不需要知道具体菜单的实现</td></tr><tr><td align="left">客户端被捆绑到了多个菜单实现类，牵一发动全身</td><td align="left">客户端可以只用 iterator 接口做参数，通过向上转型，摆脱多个具体实现的捆绑，实现解耦</td></tr></tbody></table><h3 id="继续发现问题"><a href="#继续发现问题" class="headerlink" title="继续发现问题"></a>继续发现问题</h3><p>客户端 Waitress 组合了多个具体实现类，仍然会牵一发动全身，比如修改了菜单的类名，客户端就失效，也需要修改，仍然重度依赖</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Waitress</span> </span>&#123;    <span class="hljs-comment">// 服务员依赖的菜单系统</span>    <span class="hljs-keyword">private</span> PancakeHouseMenu pancakeHouseMenu;    <span class="hljs-keyword">private</span> DinerMenu dinerMenu;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Waitress</span><span class="hljs-params">(PancakeHouseMenu pancakeHouseMenu, DinerMenu dinerMenu)</span> </span>&#123;        <span class="hljs-keyword">this</span>.pancakeHouseMenu = pancakeHouseMenu;        <span class="hljs-keyword">this</span>.dinerMenu = dinerMenu;    &#125;    ...</code></pre><p>而且，具体菜单的实现类又有共同的方法 createIterator ，完全可以进一步抽象。</p><h3 id="改进上述设计——充分利用-JDK-自带的迭代器"><a href="#改进上述设计——充分利用-JDK-自带的迭代器" class="headerlink" title="改进上述设计——充分利用 JDK 自带的迭代器"></a>改进上述设计——充分利用 JDK 自带的迭代器</h3><p>首先不再为List这样的数据结构重新实现迭代器，因为JDK 5 之后，Java 已经给我们实现好了，对于JDK 5 之后的所有集合容器，都可以采用 JDK 自带的迭代器接口——java.util,Itreator，所以我们就不用自己写，只需实现数组的迭代器即可。</p><p>1、记住：JDK 不支持为数组生成迭代器</p><p>2、java.util 包中的 Collection 接口——Java 所有的集合都实现了该接口，该接口有迭代器方法。</p><h3 id="继续改进——抽象具体类的公共部分"><a href="#继续改进——抽象具体类的公共部分" class="headerlink" title="继续改进——抽象具体类的公共部分"></a>继续改进——抽象具体类的公共部分</h3><p>可以为各个菜单实现类，提供一个公共的接口——Menu</p><h3 id="原则：面向接口编程"><a href="#原则：面向接口编程" class="headerlink" title="原则：面向接口编程"></a>原则：面向接口编程</h3><p>有多个具体实现类的时候，要首先考虑不针对实现编程，而是面向接口编程，除非有共同的抽象方法+属性时，可以考虑抽象父类。本案例中，只需使用接口，就可以减少客户端 waittress 和具体菜单实现类之间的依赖。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-20 下午9:40</span><span class="hljs-comment"> * 菜单系统要实现的方法，抽象为接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Menu</span> </span>&#123;    <span class="hljs-function">Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-20 下午9:41</span><span class="hljs-comment"> * 菜单的每项，抽象为类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuItem</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String description;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MenuItem</span><span class="hljs-params">(String name,</span></span><span class="hljs-function"><span class="hljs-params">                                               String description)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.description = description;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> description;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-20 下午9:42</span><span class="hljs-comment"> * 餐厅菜单系统的迭代器，不需要实现额外声明的迭代器接口，而是重写JDK的迭代器即可</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DinerMenuIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;    <span class="hljs-keyword">private</span> MenuItem[] items;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DinerMenuIterator</span><span class="hljs-params">(MenuItem[] items)</span> </span>&#123;        <span class="hljs-keyword">this</span>.items = items;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> position &lt; items.length &amp;&amp; items[position] != <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        MenuItem menuItem = items[position];        position = position + <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> menuItem;    &#125;    <span class="hljs-comment">// 重新实现，最好是重写</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (position &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException                    (<span class="hljs-string">&quot;You can&#x27;t remove an item until you&#x27;ve done at least one next()&quot;</span>);        &#125;        <span class="hljs-comment">// 删除线性表的元素，所有元素需要往前移动一个位置</span>        <span class="hljs-keyword">if</span> (items[position - <span class="hljs-number">1</span>] != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = position - <span class="hljs-number">1</span>; i &lt; (items.length - <span class="hljs-number">1</span>); i++) &#123;                items[i] = items[i + <span class="hljs-number">1</span>];            &#125;            items[items.length - <span class="hljs-number">1</span>] = <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-20 下午9:50</span><span class="hljs-comment"> * 餐厅菜单系统</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DinerMenu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Menu</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_ITEMS = <span class="hljs-number">6</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numberOfItems = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> MenuItem[] menuItems;    <span class="hljs-comment">// 实现方式不变</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DinerMenu</span><span class="hljs-params">()</span> </span>&#123;        menuItems = <span class="hljs-keyword">new</span> MenuItem[MAX_ITEMS];        addItem(<span class="hljs-string">&quot;Soup of the day&quot;</span>,                <span class="hljs-string">&quot;Soup of the day, with a side of potato salad&quot;</span>);    &#125;    <span class="hljs-comment">// 实现方式不变</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(String name, String description)</span> </span>&#123;        MenuItem menuItem = <span class="hljs-keyword">new</span> MenuItem(name, description);        <span class="hljs-keyword">if</span> (numberOfItems &gt;= MAX_ITEMS) &#123;            System.err.println(<span class="hljs-string">&quot;Sorry, menu is full!  Can&#x27;t add item to menu&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            menuItems[numberOfItems] = menuItem;            numberOfItems = numberOfItems + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DinerMenuIterator(menuItems);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-20 下午9:52</span><span class="hljs-comment"> * 煎饼，不需要再实现迭代器，因为使用的数据结构是JDK的容器，而对于JDK自带的集合容器，不需要自己实现迭代器</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PancakeHouseMenu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Menu</span> </span>&#123;    <span class="hljs-keyword">private</span> List&lt;MenuItem&gt; menuItems;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PancakeHouseMenu</span><span class="hljs-params">()</span> </span>&#123;        menuItems = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        addItem(<span class="hljs-string">&quot;K&amp;B&#x27;s Pancake Breakfast&quot;</span>, <span class="hljs-string">&quot;Pancakes with scrambled eggs, and toast&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(String name, String description)</span> </span>&#123;        MenuItem menuItem = <span class="hljs-keyword">new</span> MenuItem(name, description);        menuItems.add(menuItem);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 返回 JDK ArrayList 自带的迭代器 iterator() 方法</span>        <span class="hljs-keyword">return</span> menuItems.iterator();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-20 下午9:54</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Waitress</span> </span>&#123;    <span class="hljs-comment">// 服务员依赖的菜单系统——通过接口解耦合</span>    <span class="hljs-keyword">private</span> Menu pancakeHouseMenu;    <span class="hljs-keyword">private</span> Menu dinerMenu;    <span class="hljs-comment">// 修改为 Menu 接口，向上转型，解耦合</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Waitress</span><span class="hljs-params">(Menu pancakeHouseMenu, Menu dinerMenu)</span> </span>&#123;        <span class="hljs-keyword">this</span>.pancakeHouseMenu = pancakeHouseMenu;        <span class="hljs-keyword">this</span>.dinerMenu = dinerMenu;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 以后修改遍历逻辑，客户端不需要修改</span><span class="hljs-comment">     * // 不用修改</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMenu</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 为每个菜单系统，创建迭代器</span>        <span class="hljs-comment">// java.util.Iterator;</span>        Iterator pancakeIterator = pancakeHouseMenu.createIterator();        Iterator dinerIterator = dinerMenu.createIterator();        printMenu(pancakeIterator);        printMenu(dinerIterator);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 接口的用法，向上转型</span><span class="hljs-comment">     * // 不用修改</span><span class="hljs-comment">     * java.util.Iterator;</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMenu</span><span class="hljs-params">(Iterator iterator)</span> </span>&#123;        <span class="hljs-comment">// 先判断是否还能继续迭代</span>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            <span class="hljs-comment">// Iterator 接口里 next 返回的是 Object 对象，故需要强制转换</span>            MenuItem menuItem = (MenuItem) iterator.next();            System.out.print(menuItem.getName() + <span class="hljs-string">&quot;, &quot;</span>);            System.out.println(menuItem.getDescription());        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuTestDrive</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;        Menu pancakeHouseMenu = <span class="hljs-keyword">new</span> PancakeHouseMenu();        Menu dinerMenu = <span class="hljs-keyword">new</span> DinerMenu();        <span class="hljs-comment">// 即使具体的菜单实现类修改了名字或者环了实现类，客户端——Waitress 也不需要修改代码，解了耦合</span>        Waitress waitress = <span class="hljs-keyword">new</span> Waitress(pancakeHouseMenu, dinerMenu);        waitress.printMenu();    &#125;&#125;</code></pre><h3 id="针对-JDK-的迭代器重写的原则"><a href="#针对-JDK-的迭代器重写的原则" class="headerlink" title="针对 JDK 的迭代器重写的原则"></a>针对 JDK 的迭代器重写的原则</h3><h4 id="remove-方法应不应该重写"><a href="#remove-方法应不应该重写" class="headerlink" title="remove 方法应不应该重写"></a>remove 方法应不应该重写</h4><p>虽然对于客户端来说，remove 方法非必须（当然业务需要的话，就必须自定义重写 remove），但是最好还是提供该方法，因为JDK的 Iterator接口里包含了该方法，如果不一起重写，可能会出问题。</p><p>如果客户端真的不需要删除元素，那么最好也重写该方法，只需要在重写的时候抛出一个自定义的（或者现成的）异常——如果有调用，就提醒客户端不能删除元素。JDK也是这样设计的，默认抛出异常 UnsupportedOperationException</p><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>默认的迭代器接口是线程不安全的，如果有需要，要额外的加强线程安全。</p><h3 id="迭代器模式的标准概念"><a href="#迭代器模式的标准概念" class="headerlink" title="迭代器模式的标准概念"></a>迭代器模式的标准概念</h3><p>迭代器模式又叫游标(Cursor)模式、Iterator模式，迭代子模式……是对象的行为模式之一，它把对容器中包含的内部对象的访问委托给外部的类，让外部的类可以使用 Iterator 按顺序进行遍历访问，而又不暴露其内部的数据结构。</p><pre><code class="hljs pgsql">Iterator Pattern (Another <span class="hljs-type">Name</span>: <span class="hljs-keyword">Cursor</span>)Provide a way <span class="hljs-keyword">to</span> <span class="hljs-keyword">access</span> the elements <span class="hljs-keyword">of</span> an <span class="hljs-keyword">aggregate</span> <span class="hljs-keyword">object</span> sequentially <span class="hljs-keyword">without</span> exposing its underlying representation.</code></pre><p>脱离Java的领域，那么可以认为：迭代器模式可以顺序地访问聚集中的元素，而不必暴露聚集的内部状态（internal representation）。它把遍历的责任转移到了迭代器，而不是聚集本身，简化了聚集的接口和实现代码，也分割了责任。</p><h3 id="迭代器模式的角色"><a href="#迭代器模式的角色" class="headerlink" title="迭代器模式的角色"></a>迭代器模式的角色</h3><p>Iterator（迭代器接口）：该接口必须定义实现迭代功能的最小定义方法集，比如提供hasNext()和next()方法。</p><p>ConcreteIterator（具体的迭代器实现类）：迭代器接口Iterator的实现类。可以根据具体情况加以实现。</p><p>Aggregate（聚集的接口）：定义基本功能以及提供类似Iterator iterator()的方法。</p><p>concreteAggregate（聚集接口的实现类）：容器接口的实现类。必须实现生成迭代器的方法。</p><h3 id="聚集体如果不使用-Iterator-模式，会存在什么问题"><a href="#聚集体如果不使用-Iterator-模式，会存在什么问题" class="headerlink" title="聚集体如果不使用 Iterator 模式，会存在什么问题"></a>聚集体如果不使用 Iterator 模式，会存在什么问题</h3><h3 id="聚集类承担了太多功能"><a href="#聚集类承担了太多功能" class="headerlink" title="聚集类承担了太多功能"></a>聚集类承担了太多功能</h3><p>如果是自定义的聚集，那么需要由聚集自己实现顺序遍历的方法——直接在聚集的类里添加遍历方法。这样，容器类承担了太多功能：</p><p>一方面需要提供添加、删除等本身应有的功能；</p><p>一方面还需要提供遍历访问功能。</p><p>不仅责任不分离，还和客户端耦合太强</p><h3 id="暴露聚集的太多内部实现细节"><a href="#暴露聚集的太多内部实现细节" class="headerlink" title="暴露聚集的太多内部实现细节"></a>暴露聚集的太多内部实现细节</h3><p>如果不使用迭代器模式，那么需要客户端自己实现服务的遍历（联系餐厅和煎饼屋的合并案例），会直接暴露聚集的数据结构，往往这是不必要的，客户端不需要了解服务的具体实现，也是为了程序的安全——不暴露太多的内部细节给客户端。</p><h3 id="遍历聚集的时候修改聚集的元素，引起聚集的状态混乱"><a href="#遍历聚集的时候修改聚集的元素，引起聚集的状态混乱" class="headerlink" title="遍历聚集的时候修改聚集的元素，引起聚集的状态混乱"></a>遍历聚集的时候修改聚集的元素，引起聚集的状态混乱</h3><p>如果使用的是 JDK 的集合类，如果直接遍历，且遍历的时候对集合修改，会有异常抛出。因为，往往容器在实现遍历的过程中，需要保存遍历状态，当遍历操作和元素的添加、删除等操作夹杂在一起，这些更新功能在遍历的时候也被调用，很容易引起集合的状态混乱和程序运行错误等。此时应该为聚集使用迭代器模式，如果是JDK的集合类，就直接使用自带的迭代器进行迭代。</p><p>记住：Java 中的 foreach 循环看起来像一个迭代器，但实际上并不是，还是要使用迭代器模式</p><p>Iterator 支持从源集合中安全地删除对象，只需在 Iterator 上调用 remove() 即可。这样做的好处是可以避免 ConcurrentModifiedException ，这个异常顾名思意：当打开 Iterator 迭代集合时，同时又在对集合进行修改。有些集合不允许在迭代时删除或添加元素，但是调用 Iterator 的remove() 方法是个安全的做法。</p><pre><code class="hljs java"><span class="hljs-comment">//会抛出一个ConcurrentModificationException异常</span>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>));        <span class="hljs-keyword">for</span>(String s : list)&#123;            <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;a&quot;</span>))&#123;                list.remove(s);            &#125;        &#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//显示正常</span>List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>));        Iterator&lt;String&gt; iter = list.iterator();        <span class="hljs-keyword">while</span>(iter.hasNext())&#123;            String s = iter.next();            <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;a&quot;</span>))&#123;                iter.remove();            &#125;        &#125;<span class="hljs-comment">// next() 必须在 remove() 之前调用。</span><span class="hljs-comment">// 在 foreach 中，编译器会使 next() 在删除元素之后被调用，因此就会抛出 ConcurrentModificationException 异常</span></code></pre><p>参考</p><p>1、 <a href="http://www.cnblogs.com/softidea/p/3760213.html">Iterator的remove方法可保证从源集合中安全地删除对象（转）</a></p><p><a href="http://www.cnblogs.com/softidea/p/3760213.html">2、正确遍历删除List中的元素方法  </a> <a href="http://www.jb51.net/article/98763.htm">http://www.jb51.net/article/98763.htm</a></p><h3 id="使用迭代器模式的优点"><a href="#使用迭代器模式的优点" class="headerlink" title="使用迭代器模式的优点"></a>使用迭代器模式的优点</h3><p>Iterator 模式就是为了有效地处理按顺序进行遍历访问的一种设计模式，简单地说，Iterator模式提供一种有效的方法，可以屏蔽聚集对象的容器类的实现细节，而能对容器内包含的对象元素按顺序进行有效的遍历访问。所以，Iterator模式的应用场景可以归纳为以下几个：</p><ul><li>访问容器中包含的内部对象</li><li>按顺序访问</li></ul><p>优点总结：</p><p>1，实现功能分离，简化聚集的接口。让聚集只实现本身的基本功能，把迭代功能委托给外部类实现，符合类的单一职责设计原则。</p><p>2，隐藏聚集的实现细节，符合最小知道原则。为聚集或其子容器提供了一个统一接口，一方面方便客户端调用；另一方面使得客户端不必关注迭代器的实现细节。</p><p>3，可以为聚集或其子容器实现不同的迭代器，搭配其他设计模式，比如策略模式等，可以很容易的切换。</p><p>4、客户端可以同时使用多个迭代器遍历一个聚集。</p><h3 id="List-迭代的方向问题"><a href="#List-迭代的方向问题" class="headerlink" title="List 迭代的方向问题"></a>List 迭代的方向问题</h3><p>都知道，next 方法是正向遍历，那么自然可以实现反向遍历，新加一个取得前一个元素的方法 + 一个判断游标是否已经走到了首节点的方法即可解决。</p><p>JDK也为我们做了实现：ListIterator接口，提供了一个previous方法，JDK中的任何实现了List接口的集合，都可以实现反向迭代。</p><h3 id="非线性数据结构的迭代问题"><a href="#非线性数据结构的迭代问题" class="headerlink" title="非线性数据结构的迭代问题"></a>非线性数据结构的迭代问题</h3><p>澄清一个问题——迭代器模式是没有约束元素顺序的，即 next （previous）只是取出元素，并不是强制元素取出的先后顺序等价于元素的某种排序。通俗的说，不论是线性结构还是非线性的，甚至是包含重复元素的结构，除非有特殊业务需求，都能对其实现迭代器模式。</p><p>不可幻想：迭代的顺序就等价于集合中元素的某种有意义的排序，两者没有必然关系，谨记以避免做出错误判断，除非有自定义的顺序约束。</p><h3 id="单一职责设计原则和迭代器模式"><a href="#单一职责设计原则和迭代器模式" class="headerlink" title="单一职责设计原则和迭代器模式"></a>单一职责设计原则和迭代器模式</h3><p>设计原则：一个类只有一个引起变化的原因。如果有一个类具有两个改变的原因，那么这会使得将来该类的变化机率上升，而当它真的改变时，你的设计中同时又有两个方面将会受到影响。</p><h3 id="高内聚-gt-单一职责原则"><a href="#高内聚-gt-单一职责原则" class="headerlink" title="高内聚 &gt; 单一职责原则"></a>高内聚 &gt; 单一职责原则</h3><p>内聚：用来度量一个类或者模块紧密的达到了单一职责的目的（or 责任）。当一个类或者一个模块被设计为只支持一组相关的功能的时候，就说它具有高内聚的特性，反之就是低内聚的。</p><p>高内聚是一个比单一职责更普遍的概念，即遵守了高内聚的类，也同样具有单一职责。</p><h3 id="迭代器模式就遵循了单一职责原则"><a href="#迭代器模式就遵循了单一职责原则" class="headerlink" title="迭代器模式就遵循了单一职责原则"></a>迭代器模式就遵循了单一职责原则</h3><p>其实前面的分析已经很全面，迭代器模式，分离了聚集的迭代的责任，有效的契合了单一职责设计原则。</p><h3 id="扩展案例：合并咖啡厅的菜单系统"><a href="#扩展案例：合并咖啡厅的菜单系统" class="headerlink" title="扩展案例：合并咖啡厅的菜单系统"></a>扩展案例：合并咖啡厅的菜单系统</h3><p>为其合并后的系统，增加咖啡厅的菜单，供应晚餐。下面是咖啡厅的菜单系统实现：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-20 下午10:15</span><span class="hljs-comment"> * 合并之后的咖啡厅菜单实现类</span><span class="hljs-comment"> * hash表也实现了JDK的迭代器，不需要RD自己实现</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CafeMenu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Menu</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 菜单使用了hash表存储，和现有的两个菜单系统实现不一样</span><span class="hljs-comment">     * 实现不变</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Map&lt;String, MenuItem&gt; menuItems = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-comment">// 实现不变</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CafeMenu</span><span class="hljs-params">()</span> </span>&#123;        addItem(<span class="hljs-string">&quot;Veggie Burger and Air Fries&quot;</span>,                <span class="hljs-string">&quot;Veggie burger on a whole wheat bun, lettuce, tomato, and fries&quot;</span>);    &#125;    <span class="hljs-comment">// 实现不变</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addItem</span><span class="hljs-params">(String name, String description)</span> </span>&#123;        MenuItem menuItem = <span class="hljs-keyword">new</span> MenuItem(name, description);        menuItems.put(menuItem.getName(), menuItem);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * hash表支持JDK自带的迭代器 java.util.Iterator;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">createIterator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 返回 java.util.Iterator; 只需要取得 hash 表的 value 集合即可</span>        <span class="hljs-keyword">return</span> menuItems.values().iterator();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-20 下午10:16</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Waitress</span> </span>&#123;    <span class="hljs-keyword">private</span> Menu pancakeHouseMenu;    <span class="hljs-keyword">private</span> Menu dinerMenu;    <span class="hljs-comment">// 需要增加 cafeMenu</span>    <span class="hljs-keyword">private</span> Menu cafeMenu;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 如果，太多的参数，可以使用建造者模式优化构造器</span><span class="hljs-comment">     * 需要增加 cafeMenu 参数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Waitress</span><span class="hljs-params">(Menu pancakeHouseMenu, Menu dinerMenu, Menu cafeMenu)</span> </span>&#123;        <span class="hljs-keyword">this</span>.pancakeHouseMenu = pancakeHouseMenu;        <span class="hljs-keyword">this</span>.dinerMenu = dinerMenu;        <span class="hljs-keyword">this</span>.cafeMenu = cafeMenu;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 需要增加 cafeMenu 的迭代器</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMenu</span><span class="hljs-params">()</span> </span>&#123;        Iterator pancakeIterator = pancakeHouseMenu.createIterator();        Iterator dinerIterator = dinerMenu.createIterator();        Iterator cafeIterator = cafeMenu.createIterator();        printMenu(pancakeIterator);        printMenu(dinerIterator);        printMenu(cafeIterator);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 无需修改</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMenu</span><span class="hljs-params">(Iterator iterator)</span> </span>&#123;        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            MenuItem menuItem = (MenuItem) iterator.next();            System.out.print(menuItem.getName() + <span class="hljs-string">&quot;, &quot;</span>);            System.out.println(menuItem.getDescription());        &#125;    &#125;&#125;</code></pre><h3 id="继续发现系统的问题——客户端违反了开闭原则"><a href="#继续发现系统的问题——客户端违反了开闭原则" class="headerlink" title="继续发现系统的问题——客户端违反了开闭原则"></a>继续发现系统的问题——客户端违反了开闭原则</h3><p>合并咖啡厅的过程中，发现每次合并新菜单，都要打开客户端，修改代码……客户端实现很丑陋，违反了开闭原则。</p><p>虽然我们抽象了菜单，让其在客户端解耦，并且为菜单系统分别实现了迭代器，让迭代责任分离，对客户端隐藏了具体实现，使用同一的迭代器接口，解耦了迭代动作。但是，仍然将菜单处理分成独立的对象看待，导致每次扩展，都需要修改客户端——客户端需要反复写：调用printMenue的代码，代码冗余严重，而且每次都要给构造器增加新参数。</p><p>需要一种更好的办法——集中管理菜单，使其使用一个迭代器即可应付菜单的扩展</p><h4 id="解决方案：抽象客户端各个独立的菜单系统，只需保留一个迭代器"><a href="#解决方案：抽象客户端各个独立的菜单系统，只需保留一个迭代器" class="headerlink" title="解决方案：抽象客户端各个独立的菜单系统，只需保留一个迭代器"></a>解决方案：抽象客户端各个独立的菜单系统，只需保留一个迭代器</h4><p>使用现成的 ArrayList 类实现：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> iMLe0n</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 19-5-20 下午10:18</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Waitress1</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 把各个菜单系统集中到一个list，充分利用list的迭代器</span><span class="hljs-comment">     * 只需要一个类就搞定，不再每次都add一个菜单类了</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> List&lt;Menu&gt; menus;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Waitress1</span><span class="hljs-params">(List&lt;Menu&gt; menus)</span> </span>&#123;        <span class="hljs-keyword">this</span>.menus = menus;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMenu</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 取得list的迭代器，直接使用一个迭代器，就能遍历所有菜单，不需要在修改</span>        Iterator menuIterator = menus.iterator();        <span class="hljs-keyword">while</span> (menuIterator.hasNext()) &#123;            Menu menu = (Menu) menuIterator.next();            printMenu(menu.createIterator());        &#125;    &#125;    <span class="hljs-comment">// 代码不需要变</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMenu</span><span class="hljs-params">(Iterator iterator)</span> </span>&#123;        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            MenuItem menuItem = (MenuItem) iterator.next();            System.out.print(menuItem.getName() + <span class="hljs-string">&quot;, &quot;</span>);            System.out.println(menuItem.getDescription());        &#125;    &#125;&#125;</code></pre><h3 id="基于迭代器模式实现的菜单系统无法实现树状菜单（无法扩展子菜单）"><a href="#基于迭代器模式实现的菜单系统无法实现树状菜单（无法扩展子菜单）" class="headerlink" title="基于迭代器模式实现的菜单系统无法实现树状菜单（无法扩展子菜单）"></a>基于迭代器模式实现的菜单系统无法实现树状菜单（无法扩展子菜单）</h3><p>现在希望能够加上一份餐后甜点“子菜单”作为晚餐的饭后补充。如果我们能让甜点菜单变成餐厅菜单集合的一个子元素，就可以完美的解决。但是根据现在的实现，根本做不到。因为饭后甜点子菜单的实现基于数组——不变的，类型不同，无法扩展。生产环境中，这样的系统非常复杂，更加困难。</p><h3 id="解决方案——树"><a href="#解决方案——树" class="headerlink" title="解决方案——树"></a>解决方案——树</h3><p>1、需要某种树形结构，可以容纳菜单、子菜单和菜单项。</p><p>2、需要确定能够在每个菜单的各个项目之间游走，而且至少要像现在用迭代器一样方便。</p><p>3、需要能够更有弹性地在菜单项之间游走。比方说：可能只需要遍历甜点菜单，或者可以遍历餐厅的整个菜单。</p><p>此时，需要一种新的设计模式来解决这个案例的难题——组合模式</p><p>完整代码已经上传至<a href="https://github.com/iMLe0n/DesignPatterns/tree/master/src/iterator">github</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之命令模式（Command）</title>
    <link href="/2020/05/29/2019-05-08-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%88Command%EF%BC%89/"/>
    <url>/2020/05/29/2019-05-08-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%88Command%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式之命令模式（Command）"><a href="#设计模式之命令模式（Command）" class="headerlink" title="设计模式之命令模式（Command）"></a>设计模式之命令模式（Command）</h2><p>​                    <strong>把自律变成习惯</strong></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。（当需要将发出请求的对象和执行请求的对象解耦的时候，使用命令模式）</p><h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a><strong>要点：</strong></h3><ul><li>命令模式将发出请求的对象和执行请求的对象解耦。</li><li>在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接收者和一个或一组动作。</li><li>调用者通过调用命令对象的 <code>execute()</code> 发出请求，这会使得接收者的动作被调用。</li><li>调用者可以接受命令当做参数，甚至在运行时动态地进行。</li><li>命令可以支持撤销，做法是实现一个 <code>undo()</code> 方法来回到 <code>execute()</code> 被执行前的状态。</li><li>宏命令是命令的一种简单的延伸，允许调用多个命令。宏方法也可以支持撤销。</li><li>实际操作时，很常见使用“聪明”命令对象，也就是直接实现了请求，而不是将工作委托给接收者。</li><li>命令也可以用来实现日志和事务系统。</li></ul><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a><strong>类图</strong></h3><ul><li>Command：命令</li><li>Receiver：命令接收者，也就是命令真正的执行者</li><li>Invoker：通过它来调用命令</li><li>Client：可以设置命令与命令的接收者</li></ul><p><img src="/img/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h3><p><img src="/img/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0.jpg"></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Command</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Light</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Light is on&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Light is off&quot;</span>);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LightOnCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Command</span> </span>&#123;    Light light;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LightOnCommand</span><span class="hljs-params">(Light light)</span> </span>&#123;        <span class="hljs-keyword">this</span>.light = light;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;        light.on();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LightOffCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Command</span> </span>&#123;    Light light;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LightOffCommand</span><span class="hljs-params">(Light light)</span> </span>&#123;        <span class="hljs-keyword">this</span>.light = light;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;        light.off();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoker</span> </span>&#123;    <span class="hljs-keyword">private</span> Command[] onCommands;    <span class="hljs-keyword">private</span> Command[] offCommands;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> slotNum = <span class="hljs-number">7</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Invoker</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.onCommands = <span class="hljs-keyword">new</span> Command[slotNum];        <span class="hljs-keyword">this</span>.offCommands = <span class="hljs-keyword">new</span> Command[slotNum];    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOnCommand</span><span class="hljs-params">(Command command, <span class="hljs-keyword">int</span> slot)</span> </span>&#123;        onCommands[slot] = command;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOffCommand</span><span class="hljs-params">(Command command, <span class="hljs-keyword">int</span> slot)</span> </span>&#123;        offCommands[slot] = command;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onButtonWasPushed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> slot)</span> </span>&#123;        onCommands[slot].execute();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">offButtonWasPushed</span><span class="hljs-params">(<span class="hljs-keyword">int</span> slot)</span> </span>&#123;        offCommands[slot].execute();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Invoker invoker = <span class="hljs-keyword">new</span> Invoker();        Light light = <span class="hljs-keyword">new</span> Light();        GarageDoor garageDoor = <span class="hljs-keyword">new</span> GarageDoor();        LightOnCommand lightOnCommand = <span class="hljs-keyword">new</span> LightOnCommand(light);        LightOffCommand lightOffCommand = <span class="hljs-keyword">new</span> LightOffCommand(light);        GarageDoorOpenCommand garageDoorOpenCommand = <span class="hljs-keyword">new</span> GarageDoorOpenCommand(garageDoor);        invoker.setOnCommand(lightOnCommand,<span class="hljs-number">0</span>);        invoker.setOffCommand(lightOffCommand,<span class="hljs-number">0</span>);        invoker.onButtonWasPushed(<span class="hljs-number">0</span>);        invoker.offButtonWasPushed(<span class="hljs-number">0</span>);        invoker.setOnCommand(garageDoorOpenCommand,<span class="hljs-number">1</span>);        invoker.onButtonWasPushed(<span class="hljs-number">1</span>);    &#125;&#125;</code></pre><p>完整代码已经上传至<a href="https://github.com/iMLe0n/DesignPatterns/tree/master/src/command">github</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之工厂模式（Factory）</title>
    <link href="/2020/05/29/2019-04-29-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Factory%EF%BC%89/"/>
    <url>/2020/05/29/2019-04-29-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Factory%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式之工厂模式（Factory）"><a href="#设计模式之工厂模式（Factory）" class="headerlink" title="设计模式之工厂模式（Factory）"></a>设计模式之工厂模式（Factory）</h2><p>​    <strong>能胜强敌者，先自胜者也。——《商君书·画策》</strong></p><ul><li>简单工厂模式（Simple Factory）</li><li>工厂方法模式（Factory Method）</li><li>抽象工厂模式（Abstract Factory）</li></ul><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22779936&auto=0&height=66"></iframe><h3 id="简单工厂模式（Simple-Factory）"><a href="#简单工厂模式（Simple-Factory）" class="headerlink" title="简单工厂模式（Simple Factory）"></a><strong>简单工厂模式（Simple Factory）</strong></h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。（其实，简单工厂模式并不是一种设计模式，反而比较像是一种编程习惯，而因为经常被使用，被误认为是“工厂模式” ）。</p><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</p><p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p><p><img src="/images/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pizza</span> </span>&#123;    String name;    String dough;    String sauce;    ArrayList&lt;String&gt; toppings = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Preparing &quot;</span> + name);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bake</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Baking &quot;</span> + name);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cut</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Cutting &quot;</span> + name);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">box</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">&quot;Cutting &quot;</span> + name);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        StringBuffer display = <span class="hljs-keyword">new</span> StringBuffer();        display.append(<span class="hljs-string">&quot;---- &quot;</span> + name + <span class="hljs-string">&quot; ----\n&quot;</span>);        display.append(dough + <span class="hljs-string">&quot;\n&quot;</span>);        display.append(sauce + <span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-keyword">for</span> (String topping : toppings)&#123;            display.append(topping + <span class="hljs-string">&quot;\n&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> display.toString();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheesePizza</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pizza</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CheesePizza</span><span class="hljs-params">()</span> </span>&#123;        name = <span class="hljs-string">&quot;Cheese Pizza&quot;</span>;        dough = <span class="hljs-string">&quot;Regular Crust&quot;</span>;        sauce = <span class="hljs-string">&quot;Marinara Pizza Sauce&quot;</span>;        toppings.add(<span class="hljs-string">&quot;Fresh Mozzarella&quot;</span>);        toppings.add(<span class="hljs-string">&quot;Parmesan&quot;</span>);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimplePizzaFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">createPizza</span><span class="hljs-params">(String type)</span> </span>&#123;        Pizza pizza = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">&quot;cheese&quot;</span>)) &#123;            pizza = <span class="hljs-keyword">new</span> CheesePizza();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">&quot;pepperoni&quot;</span>)) &#123;            pizza = <span class="hljs-keyword">new</span> PepperoniPizza();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">&quot;clam&quot;</span>)) &#123;            pizza = <span class="hljs-keyword">new</span> ClamPizza();        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.equals(<span class="hljs-string">&quot;veggie&quot;</span>)) &#123;            pizza = <span class="hljs-keyword">new</span> VeggiePizza();        &#125;        <span class="hljs-keyword">return</span> pizza;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PizzaStore</span> </span>&#123;    SimplePizzaFactory factory;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PizzaStore</span><span class="hljs-params">(SimplePizzaFactory factory)</span> </span>&#123;        <span class="hljs-keyword">this</span>.factory = factory;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">orderPizza</span><span class="hljs-params">(String type)</span> </span>&#123;        Pizza pizza;        pizza = factory.createPizza(type);        pizza.prepare();        pizza.bake();        pizza.cut();        pizza.box();        <span class="hljs-keyword">return</span> pizza;    &#125;&#125;</code></pre><p>完整代码已经上传至<a href="https://github.com/iMLe0n/DesignPatterns/tree/master/src/factory/simpleFactory">github</a></p><h3 id="工厂方法模式（Factory-Method）"><a href="#工厂方法模式（Factory-Method）" class="headerlink" title="工厂方法模式（Factory Method）"></a><strong>工厂方法模式（Factory Method）</strong></h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong></h4><p>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p><h4 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h4><p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</p><p>下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。</p><p><img src="/images/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9B%BE.png"></p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PizzaStore</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> Pizza <span class="hljs-title">createPizza</span><span class="hljs-params">(String item)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> Pizza <span class="hljs-title">orderPizza</span><span class="hljs-params">(String type)</span></span>&#123;        Pizza pizza = createPizza(type);        System.out.println(<span class="hljs-string">&quot;--- Making a &quot;</span> + pizza.getName() + <span class="hljs-string">&quot; ---&quot;</span>);        pizza.prepare();        pizza.bake();        pizza.cut();        pizza.box();        <span class="hljs-keyword">return</span> pizza;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChicagoPizzaStore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PizzaStore</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">Pizza <span class="hljs-title">createPizza</span><span class="hljs-params">(String item)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (item) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;cheese&quot;</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChicagoStyleCheesePizza();            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;veggie&quot;</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChicagoStyleVeggiePizza();            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;clam&quot;</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChicagoStyleClamPizza();            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pepperoni&quot;</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChicagoStylePepperoniPizza();            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NYPizzaStore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PizzaStore</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function">Pizza <span class="hljs-title">createPizza</span><span class="hljs-params">(String item)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (item) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;cheese&quot;</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NYStyleCheesePizza();            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;veggie&quot;</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NYStyleVeggiePizza();            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;clam&quot;</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NYStyleClamPizza();            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pepperoni&quot;</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NYStylePepperoniPizza();            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;</code></pre><p>完整代码已经上传至<a href="https://github.com/iMLe0n/DesignPatterns/tree/master/src/factory/factorymethod">github</a></p><h3 id="抽象工厂模式（Abstract-Factory）"><a href="#抽象工厂模式（Abstract-Factory）" class="headerlink" title="抽象工厂模式（Abstract Factory）"></a>抽象工厂模式（Abstract Factory）</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a><strong>定义</strong></h4><p>抽象工厂模式提供一个接口，用于创建或依赖对象的家族，而不需要明确指定具体类。</p><h4 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a><strong>类图</strong></h4><p><img src="https://upload.wikimedia.org/wikipedia/commons/a/a7/Abstract_factory.svg"></p><p><code>GuiFactory</code>接口中的<code>createButton</code>方法返回<code>Button</code>类型的对象。返回<code>Button</code>的哪种实现依赖于使用<code>GuiFactory</code>的哪种实现。</p><p>需要注意的是，为了简洁起见，以上类图仅仅展示了创建一个类型对象的工厂。而在抽象工厂模式中，通常一个工厂能够创建若干种不同类型的对象。</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a><strong>实现</strong></h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Button</span> </span>&#123;     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getButton</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MacButton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Button</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getButton</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;MacButton&quot;</span>);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WinButton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Button</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getButton</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;WinButton&quot;</span>);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GUIFactory</span> </span>&#123;    <span class="hljs-function">Button <span class="hljs-title">createButton</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">Border <span class="hljs-title">createBorder</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MacFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GUIFactory</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Button <span class="hljs-title">createButton</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MacButton();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Border <span class="hljs-title">createBorder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MacBorder();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WinFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GUIFactory</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Button <span class="hljs-title">createButton</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WinButton();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Border <span class="hljs-title">createBorder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WinBorder();    &#125;&#125;</code></pre><p>完整代码已经上传至<a href="https://github.com/iMLe0n/DesignPatterns/tree/master/src/factory/abstractfactory">github</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之适配器模式（Adapter）</title>
    <link href="/2020/05/29/2019-05-09-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Adapter%EF%BC%89/"/>
    <url>/2020/05/29/2019-05-09-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Adapter%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式之适配器模式（Adapter）"><a href="#设计模式之适配器模式（Adapter）" class="headerlink" title="设计模式之适配器模式（Adapter）"></a>设计模式之适配器模式（Adapter）</h2><p>​        <strong>刻意练习很重要</strong></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p><p><img src="/img/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89%E5%9B%BE.png"></p><p><strong>要点</strong></p><ul><li>当需要使用一个现有的类而其接口并不符合你的需要时，就使用适配器。</li><li>适配器改变接口以符合客户的期望。</li><li>实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小与复杂度而定。</li><li>适配器模式有两种形式：对象适配器和类适配器。类适配器需要用到多重继承。</li></ul><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a><strong>类图</strong></h3><p><img src="/img/%E9%80%82%E9%85%8D%E5%99%A8%E7%B1%BB%E5%9B%BE.png"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h3><p>鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，和不同的飞行距离，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。</p><p>要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Duck</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quack</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Turkey</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gobble</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WildTurkey</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Turkey</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">gobble</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Gobble gobble&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;I&#x27;m flying a short distance&quot;</span>);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TurkeyAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Duck</span> </span>&#123;    Turkey turkey;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TurkeyAdapter</span><span class="hljs-params">(Turkey turkey)</span> </span>&#123;        <span class="hljs-keyword">this</span>.turkey = turkey;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quack</span><span class="hljs-params">()</span> </span>&#123;        turkey.gobble();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            turkey.fly();        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DuckTestDrive</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MallardDuck duck = <span class="hljs-keyword">new</span> MallardDuck();        WildTurkey wildTurkey = <span class="hljs-keyword">new</span> WildTurkey();        Duck turkeyAdapter = <span class="hljs-keyword">new</span> TurkeyAdapter(wildTurkey);        System.out.println(<span class="hljs-string">&quot;The Turkey says...&quot;</span>);        wildTurkey.gobble();        wildTurkey.fly();        System.out.println(<span class="hljs-string">&quot;\nThe Duck says...&quot;</span>);        testDuck(duck);        System.out.println(<span class="hljs-string">&quot;\nThe TurkeyAdapter says...&quot;</span>);        testDuck(turkeyAdapter);    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDuck</span><span class="hljs-params">(Duck duck)</span></span>&#123;        duck.quack();        duck.fly();    &#125;&#125;</code></pre><p>完整代码已经上传至<a href="https://github.com/iMLe0n/DesignPatterns/tree/master/src/adapter">github</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之外观模式（Facade）</title>
    <link href="/2020/05/29/2019-05-11-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%EF%BC%88Facade%EF%BC%89/"/>
    <url>/2020/05/29/2019-05-11-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%EF%BC%88Facade%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式之外观模式（Facade）"><a href="#设计模式之外观模式（Facade）" class="headerlink" title="设计模式之外观模式（Facade）"></a>设计模式之外观模式（Facade）</h2><p>​                <strong>一定要逼迫自己跳出舒适圈</strong></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a><strong>要点</strong></h3><ul><li>当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观。</li><li>外观将客户从一个复杂的子系统中解耦。</li><li>实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行。</li><li>你可以为一个子系统实现一个以上的外观。</li><li>适配器将一个对象包装起来以改变气接口；装饰者将一个对象包装起来以增加新的行为和责任；而外观将一群对象“包装”起来以简化其接口。</li></ul><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a><strong>类图</strong></h3><p><img src="/img/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h3><p>使用外观模式实现家庭影院功能。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Amplifier</span> </span>&#123;    String description;    Tuner tuner;    DvdPlayer dvd;    CdPlayer cd;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Amplifier</span><span class="hljs-params">(String description)</span> </span>&#123;        <span class="hljs-keyword">this</span>.description = description;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(description + <span class="hljs-string">&quot; on&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(description + <span class="hljs-string">&quot; off&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStereoSound</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(description + <span class="hljs-string">&quot; stereo mode on&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSurroundSound</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(description + <span class="hljs-string">&quot; surround sound on (5 speakers, 1 subwoofer)&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setVolume</span><span class="hljs-params">(<span class="hljs-keyword">int</span> level)</span> </span>&#123;        System.out.println(description + <span class="hljs-string">&quot; setting volume to &quot;</span> + level);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTuner</span><span class="hljs-params">(Tuner tuner)</span> </span>&#123;        System.out.println(description + <span class="hljs-string">&quot; setting tuner to &quot;</span> + dvd);        <span class="hljs-keyword">this</span>.tuner = tuner;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDvd</span><span class="hljs-params">(DvdPlayer dvd)</span> </span>&#123;        System.out.println(description + <span class="hljs-string">&quot; setting DVD player to &quot;</span> + dvd);        <span class="hljs-keyword">this</span>.dvd = dvd;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCd</span><span class="hljs-params">(CdPlayer cd)</span> </span>&#123;        System.out.println(description + <span class="hljs-string">&quot; setting CD player to &quot;</span> + cd);        <span class="hljs-keyword">this</span>.cd = cd;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> description;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CdPlayer</span> </span>&#123;    String description;    <span class="hljs-keyword">int</span> currentTrack;    Amplifier amplifier;    String title;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CdPlayer</span><span class="hljs-params">(String description, Amplifier amplifier)</span> </span>&#123;        <span class="hljs-keyword">this</span>.description = description;        <span class="hljs-keyword">this</span>.amplifier = amplifier;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(description + <span class="hljs-string">&quot; on&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(description + <span class="hljs-string">&quot; off&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eject</span><span class="hljs-params">()</span> </span>&#123;        title = <span class="hljs-keyword">null</span>;        System.out.println(description + <span class="hljs-string">&quot; eject&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String title)</span> </span>&#123;        <span class="hljs-keyword">this</span>.title = title;        currentTrack = <span class="hljs-number">0</span>;        System.out.println(description + <span class="hljs-string">&quot; playing \&quot;&quot;</span> + title + <span class="hljs-string">&quot;\&quot;&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(<span class="hljs-keyword">int</span> track)</span> </span>&#123;        <span class="hljs-keyword">if</span> (title == <span class="hljs-keyword">null</span>) &#123;            System.out.println(description + <span class="hljs-string">&quot; can&#x27;t play track &quot;</span> + currentTrack +                    <span class="hljs-string">&quot;, no cd inserted&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            currentTrack = track;            System.out.println(description + <span class="hljs-string">&quot; playing track &quot;</span> + currentTrack);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;        currentTrack = <span class="hljs-number">0</span>;        System.out.println(description + <span class="hljs-string">&quot; stopped&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pause</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(description + <span class="hljs-string">&quot; paused \&quot;&quot;</span> + title + <span class="hljs-string">&quot;\&quot;&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> description;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeTheaterFacade</span> </span>&#123;    Amplifier amp;    Tuner tuner;    DvdPlayer dvd;    CdPlayer cd;    Projector projector;    TheaterLights lights;    Screen screen;    PopcornPopper popper;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HomeTheaterFacade</span><span class="hljs-params">(Amplifier amp,</span></span><span class="hljs-function"><span class="hljs-params">                             Tuner tuner,</span></span><span class="hljs-function"><span class="hljs-params">                             DvdPlayer dvd,</span></span><span class="hljs-function"><span class="hljs-params">                             CdPlayer cd,</span></span><span class="hljs-function"><span class="hljs-params">                             Projector projector,</span></span><span class="hljs-function"><span class="hljs-params">                             Screen screen,</span></span><span class="hljs-function"><span class="hljs-params">                             TheaterLights lights,</span></span><span class="hljs-function"><span class="hljs-params">                             PopcornPopper popper)</span> </span>&#123;        <span class="hljs-keyword">this</span>.amp = amp;        <span class="hljs-keyword">this</span>.tuner = tuner;        <span class="hljs-keyword">this</span>.dvd = dvd;        <span class="hljs-keyword">this</span>.cd = cd;        <span class="hljs-keyword">this</span>.projector = projector;        <span class="hljs-keyword">this</span>.screen = screen;        <span class="hljs-keyword">this</span>.lights = lights;        <span class="hljs-keyword">this</span>.popper = popper;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">watchMovie</span><span class="hljs-params">(String movie)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Get ready to watch a movie...&quot;</span>);        popper.on();        popper.pop();        lights.dim(<span class="hljs-number">10</span>);        screen.down();        projector.on();        projector.wideScreenMode();        amp.on();        amp.setDvd(dvd);        amp.setSurroundSound();        amp.setVolume(<span class="hljs-number">5</span>);        dvd.on();        dvd.play(movie);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endMovie</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Shutting movie theater down...&quot;</span>);        popper.off();        lights.on();        screen.up();        projector.off();        amp.off();        dvd.stop();        dvd.eject();        dvd.off();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenToCd</span><span class="hljs-params">(String cdTitle)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Get ready for an audiopile experence...&quot;</span>);        lights.on();        amp.on();        amp.setVolume(<span class="hljs-number">5</span>);        amp.setCd(cd);        amp.setStereoSound();        cd.on();        cd.play(cdTitle);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endCd</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Shutting down CD...&quot;</span>);        amp.off();        amp.setCd(cd);        cd.eject();        cd.off();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listenToRadio</span><span class="hljs-params">(<span class="hljs-keyword">double</span> frequency)</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Tuning in the airwaves...&quot;</span>);        tuner.on();        tuner.setFrequency(frequency);        amp.on();        amp.setVolume(<span class="hljs-number">5</span>);        amp.setTuner(tuner);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">endRadio</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Shutting down the tuner...&quot;</span>);        tuner.off();        amp.off();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeTheaterTestDrive</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Amplifier amp = <span class="hljs-keyword">new</span> Amplifier(<span class="hljs-string">&quot;Top-O-Line Amplifier&quot;</span>);        Tuner tuner = <span class="hljs-keyword">new</span> Tuner(<span class="hljs-string">&quot;Top-O-Line AM/FM Tuner&quot;</span>, amp);        DvdPlayer dvd = <span class="hljs-keyword">new</span> DvdPlayer(<span class="hljs-string">&quot;Top-O-Line DVD Player&quot;</span>, amp);        CdPlayer cd = <span class="hljs-keyword">new</span> CdPlayer(<span class="hljs-string">&quot;Top-O-Line CD Player&quot;</span>, amp);        Projector projector = <span class="hljs-keyword">new</span> Projector(<span class="hljs-string">&quot;Top-O-Line Projector&quot;</span>, dvd);        TheaterLights lights = <span class="hljs-keyword">new</span> TheaterLights(<span class="hljs-string">&quot;Theater Ceiling Lights&quot;</span>);        Screen screen = <span class="hljs-keyword">new</span> Screen(<span class="hljs-string">&quot;Theater Screen&quot;</span>);        PopcornPopper popper = <span class="hljs-keyword">new</span> PopcornPopper(<span class="hljs-string">&quot;Popcorn Popper&quot;</span>);        HomeTheaterFacade homeTheater =                <span class="hljs-keyword">new</span> HomeTheaterFacade(amp, tuner, dvd, cd,                        projector, screen, lights, popper);        homeTheater.watchMovie(<span class="hljs-string">&quot;Raiders of the Lost Ark&quot;</span>);        homeTheater.endMovie();    &#125;&#125;</code></pre><p>完整代码已经上传至<a href="https://github.com/iMLe0n/DesignPatterns/tree/master/src/facade/hometheater">github</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之单例模式（Singleton）</title>
    <link href="/2020/05/29/2019-05-07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton%EF%BC%89/"/>
    <url>/2020/05/29/2019-05-07-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式之单例模式（Singleton）"><a href="#设计模式之单例模式（Singleton）" class="headerlink" title="设计模式之单例模式（Singleton）"></a>设计模式之单例模式（Singleton）</h2><p>​    只要你每天都在学习，那么你就胜过百分之九十的人了。    </p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>​    确保一个类只有一个实例，并提供一个全局访问点</p><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a><strong>要点</strong></h3><ul><li>单例模式确保程序中一个类最多只有一个实例。</li><li>单例模式也提供访问这个实例的全局点。</li><li>在 JAVA 中实现单例模式需要私有的构造器，一个静态方法和静态变量。</li><li>确定在性能和资源上的限制，然后小心地选择适当的方案来实现单例，以解决多线程的问题（我们必须认定所有的程序都是多线程的）。</li><li>如果不是采用第五版的 JAVA 2，双重检查加锁实现会失效。</li><li>小心，你如果使用多个类加载器，可能导致单例失效而产生多个实例。</li><li>如果使用 JVM 1.2 或之前的版本，你必须建立单间注册表，以免垃圾收集器将单例收回。</li></ul><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a><strong>类图</strong></h3><p>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</p><p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p><p><img src="/img/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h3><h4 id="懒汉式-线程不安全（经典单例模式）"><a href="#懒汉式-线程不安全（经典单例模式）" class="headerlink" title="懒汉式-线程不安全（经典单例模式）"></a><strong>懒汉式-线程不安全</strong>（经典单例模式）</h4><p>以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。</p><p>这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 <code>if (uniqueInstance == null)</code> ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 <code>uniqueInstance = new Singleton();</code> 语句，这将导致实例化多次 uniqueInstance。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>)&#123;            uniqueInstance = <span class="hljs-keyword">new</span> Singleton();        &#125;        <span class="hljs-keyword">return</span> uniqueInstance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I&#x27;m a classic Singleton!&quot;</span>;    &#125;&#125;</code></pre><h4 id="饿汉式-线程安全（静态初始化）"><a href="#饿汉式-线程安全（静态初始化）" class="headerlink" title="饿汉式-线程安全（静态初始化）"></a><strong>饿汉式-线程安全（静态初始化）</strong></h4><p>线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。</p><p>但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance = <span class="hljs-keyword">new</span> Singleton();    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> uniqueInstance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I&#x27;m a statically initialized Singleton!&quot;</span>;    &#125;&#125;</code></pre><h4 id="懒汉式-线程安全（共有静态方法加锁）"><a href="#懒汉式-线程安全（共有静态方法加锁）" class="headerlink" title="懒汉式-线程安全（共有静态方法加锁）"></a><strong>懒汉式-线程安全</strong>（共有静态方法加锁）</h4><p>只需要对 getInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。</p><p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;            uniqueInstance = <span class="hljs-keyword">new</span> Singleton();        &#125;        <span class="hljs-keyword">return</span> uniqueInstance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I&#x27;m a thread safe Singleton!&quot;</span>;    &#125;&#125;</code></pre><h4 id="双重校验锁-线程安全"><a href="#双重校验锁-线程安全" class="headerlink" title="双重校验锁-线程安全"></a><strong>双重校验锁-线程安全</strong></h4><p>uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。</p><p>双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton uniqueInstance;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;                uniqueInstance = <span class="hljs-keyword">new</span> Singleton();            &#125;        &#125;        <span class="hljs-keyword">return</span> uniqueInstance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I&#x27;m a double check lock thread safe Singleton!&quot;</span>;    &#125;&#125;</code></pre><p>完整代码已经上传至<a href="https://github.com/iMLe0n/DesignPatterns/tree/master/src/singleton">github</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在CLI中高效移动</title>
    <link href="/2020/05/29/2019-04-26-%E5%9C%A8CLI%E4%B8%AD%E9%AB%98%E6%95%88%E7%A7%BB%E5%8A%A8/"/>
    <url>/2020/05/29/2019-04-26-%E5%9C%A8CLI%E4%B8%AD%E9%AB%98%E6%95%88%E7%A7%BB%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>我厌倦了在命令行中移动时敲击箭头键，但是我一直忘记了能够帮助我更有效地移动的键盘缩略图，所以这是一个简单的flashcard格式图表供将来参考！</p><p><img src="/img/moving_cli.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之策略模式（Strategy）</title>
    <link href="/2020/05/29/2019-04-26-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Strategy%EF%BC%89/"/>
    <url>/2020/05/29/2019-04-26-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Strategy%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式之策略模式（Strategy）"><a href="#设计模式之策略模式（Strategy）" class="headerlink" title="设计模式之策略模式（Strategy）"></a>设计模式之策略模式（Strategy）</h2><p>​    之前的那个博客不想用了,搭建在自己的服务器上面,数据库什么的还都要维护,比较麻烦,然后用github pages 和 jekyll 搭建了一个博客,大道至简,看起来清爽多了.废话不多说,好好写文章了.准备把所有的设计模式写完.因为最近不忙.啊呼呼呼呼<del>~</del></p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a><strong>策略模式</strong></h3><p><strong>定义</strong></p><p>​    定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p><p><strong>要点</strong></p><ul><li>知道 OO 基础，并不足以让你设计出良好的 OO 系统。</li><li>良好的 OO 设计必须具备可复用、可扩充、可维护三个特性。</li><li>模式可以让我们建造出具有良好 OO 设计质量的系统。</li><li>模式被认为是历经验证的 OO 设计经验。</li><li>模式不是代码，而是针对设计问题的通用解决方案。你可把它们应用到特定的应用中。</li><li>模式不是被发明，而是被发现。</li><li>大多数的模式和原则，都着眼于软件变化的主题。</li><li>大多数的模式都允许系统局部改变独立于其他部分。</li><li>我们常把系统中会变化的部分抽出来封装。</li><li>模式让开发人员之间有共享的语言，能够最大化沟通的价值。</li></ul><p><strong>设计原则</strong></p><ul><li>找出应用中可能需要的变化之处,把他们独立出来，不要和那些不要变化的代码混合在一起。</li><li>针对接口编程，而不是针对实现编程</li><li>多用组合，少用继承</li></ul><h3 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><ul><li>Strategy 接口定义了一个算法族，它们都实现了 behavior() 方法。</li><li>Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。</li></ul><p><img src="/img/strategy.png"></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">QuackBehavior</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quack</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">QuackBehavior</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quack</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Quack&quot;</span>);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Squeak</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">QuackBehavior</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quack</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Squeak&quot;</span>);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span> </span>&#123;    <span class="hljs-keyword">protected</span> QuackBehavior quackBehavior;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performQuack</span><span class="hljs-params">()</span></span>&#123;        quackBehavior.quack();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setQuackBehavior</span><span class="hljs-params">(QuackBehavior quackBehavior)</span> </span>&#123;        <span class="hljs-keyword">this</span>.quackBehavior = quackBehavior;    &#125;&#125;</code></pre><p>完整代码已经上传至<a href="https://github.com/iMLe0n/DesignPatterns/tree/master/src/strategy">github</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之装饰者模式（Decorator）</title>
    <link href="/2020/05/29/2019-04-28-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Decorator%EF%BC%89/"/>
    <url>/2020/05/29/2019-04-28-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Decorator%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式之装饰者模式（Decorator）"><a href="#设计模式之装饰者模式（Decorator）" class="headerlink" title="设计模式之装饰者模式（Decorator）"></a>设计模式之装饰者模式（Decorator）</h2><p>​    每日鸡汤，今天的金句还是 <strong><em>自助者天助</em></strong>，今天也要加油哦！</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1336856447&auto=0&height=66"></iframe><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a><strong>装饰者模式</strong></h3><p><strong>定义</strong></p><p>​    动态的将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。（为对象动态的添加功能）</p><p><strong>要点</strong></p><ul><li>继承属于扩展形式之一，但不见得是达到弹性设计的最佳方式。</li><li>在我们的设计中，应该允许行为可以被扩展，而无须修改现有的代码。</li><li>组合和委托可用于在运行时动态地加上新的行为。</li><li>除了继承，装饰者模式也可以让我们扩展行为。</li><li>装饰者模式意味着一群装饰者类，这些类用来包装具体组件。</li><li>装饰者类反映出被装饰的组件类型（事实上，它们具有相同的类型，都经过接口或继承实现）。</li><li>装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。</li><li>你可以用无数个装饰者包装一个组件。</li><li>装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。</li><li>装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。</li></ul><p><strong>设计原则</strong></p><ul><li>开放-关闭原则，类应该对扩展开放，对修改关闭。</li></ul><h3 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。</p><p><img src="/img/decoratorClassDiagram.png"></p><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。</p><p>下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。</p><p><img src="/img/decoratorImplementation.jpg"></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Beverage</span> </span>&#123;    String description = <span class="hljs-string">&quot;Unknow Beverage&quot;</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> description;    &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CondimentDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DarkRoast</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DarkRoast</span><span class="hljs-params">()</span> </span>&#123;        description = <span class="hljs-string">&quot;Dark Roast Coffee&quot;</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> .<span class="hljs-number">99</span>;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Espresso</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Beverage</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Espresso</span><span class="hljs-params">()</span> </span>&#123;        description = <span class="hljs-string">&quot;Espresso&quot;</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1.99</span>;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mocha</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CondimentDecorator</span> </span>&#123;    Beverage beverage;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Mocha</span><span class="hljs-params">(Beverage beverage)</span> </span>&#123;        <span class="hljs-keyword">this</span>.beverage = beverage;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> beverage.getDescription() + <span class="hljs-string">&quot;,Mocha&quot;</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> .<span class="hljs-number">2</span> + beverage.cost();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Whip</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CondimentDecorator</span> </span>&#123;    Beverage beverage;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Whip</span><span class="hljs-params">(Beverage beverage)</span> </span>&#123;        <span class="hljs-keyword">this</span>.beverage = beverage;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> beverage.getDescription() + <span class="hljs-string">&quot;, whip&quot;</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> .<span class="hljs-number">1</span> + beverage.cost();    &#125;&#125;</code></pre><p>完整代码已经上传至<a href="https://github.com/iMLe0n/DesignPatterns/tree/master/src/decorator/starbuzz">github</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之观察者模式（Observe）</title>
    <link href="/2020/05/29/2019-04-27-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Observe%EF%BC%89/"/>
    <url>/2020/05/29/2019-04-27-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Observe%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式之观察者模式（Observe）"><a href="#设计模式之观察者模式（Observe）" class="headerlink" title="设计模式之观察者模式（Observe）"></a>设计模式之观察者模式（Observe）</h2><p>​    每天都要坚持学习哦，不进则退，自助者天助，这句话是哥哥嘴里说的，我觉得很有道理。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><strong>观察者模式</strong></h3><p><strong>定义</strong></p><p>​    定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖者都会受到通知并自动更新。</p><p><img src="/img/obverse.jpg"></p><p><strong>要点</strong></p><ul><li>观察者模式定义了对象之间一对多的关系</li><li>主题（也就是可观察者）用一个共同的接口来更新观察者</li><li>观察者和可观察者之间用松耦合方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口。</li><li>使用此模式时，你可从被观察者处推（push）或者（pull）拉数据（然而，推的方式被认为更正确）</li><li>有多个观察者时，不可以依赖特定的通知次序</li><li>Java有多种观察者模式的实现，包括了通用的<code>java.util.Observable</code></li><li>要注意<code>java.util.Observable</code>实现上所带来的一些问题</li><li>如果有必要的话，可以实现自己的<code>Observable</code>，这并不难，不要害怕</li><li>Swing大量使用观察者模式，许多GUI框架也是如此</li><li>此模式也被应用在许多地方，例如：<code>JavaBeans</code>、<code>RMI</code></li></ul><p><strong>设计原则</strong></p><ul><li>为了交互对象之间的松耦合设计而努力</li></ul><h3 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h3><p>主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。</p><p>观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。</p><p><img src="/img/observer.png"></p><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。</p><p><img src="/img/observeExample.jpg"></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span><span class="hljs-params">(Observer o)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer o)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeatherData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span> </span>&#123;    <span class="hljs-keyword">private</span> ArrayList observers;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> temperature;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> humidity;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> pressure;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeatherData</span><span class="hljs-params">()</span> </span>&#123;        observers = <span class="hljs-keyword">new</span> ArrayList();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span><span class="hljs-params">(Observer o)</span> </span>&#123;        observers.add(o);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer o)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = observers.indexOf(o);        <span class="hljs-keyword">if</span> (i &gt;=<span class="hljs-number">0</span>) &#123;            observers.remove(i);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; observers.size(); i++) &#123;            Observer observer = (Observer) observers.get(i);            observer.update(temperature,humidity,pressure);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measurementsChanged</span><span class="hljs-params">()</span> </span>&#123;        notifyObservers();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMeasurements</span><span class="hljs-params">(<span class="hljs-keyword">float</span> temperature,<span class="hljs-keyword">float</span> humidity,<span class="hljs-keyword">float</span> pressure)</span></span>&#123;        <span class="hljs-keyword">this</span>.temperature = temperature;        <span class="hljs-keyword">this</span>.humidity = humidity;        <span class="hljs-keyword">this</span>.pressure = pressure;        measurementsChanged();    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">float</span> temp, <span class="hljs-keyword">float</span> humidity, <span class="hljs-keyword">float</span> pressure)</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DisplayElement</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CurrentConditionsDisplay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span>,<span class="hljs-title">DisplayElement</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> temperature;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> humidity;    <span class="hljs-keyword">private</span> Subject weatherData;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CurrentConditionsDisplay</span><span class="hljs-params">(Subject weatherData)</span> </span>&#123;        <span class="hljs-keyword">this</span>.weatherData = weatherData;        weatherData.registerObserver(<span class="hljs-keyword">this</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Current conditions: &quot;</span> + temperature                + <span class="hljs-string">&quot;F degrees and &quot;</span> + humidity + <span class="hljs-string">&quot;% humidity&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">float</span> temp, <span class="hljs-keyword">float</span> humidity, <span class="hljs-keyword">float</span> pressure)</span> </span>&#123;        <span class="hljs-keyword">this</span>.temperature = temp;        <span class="hljs-keyword">this</span>.humidity = humidity;        display();    &#125;&#125;</code></pre><p>完整代码已经上传至<a href="https://github.com/iMLe0n/DesignPatterns/tree/master/src/observe">github</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
